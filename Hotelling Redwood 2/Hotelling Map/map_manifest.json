[{"fields": {"name": "Hotelling Map", "admin_css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n.no-margin {\r\n  margin: 0px;\r\n}", "comments": "Port of Hotelling Circle to Redwood2\r\n\r\nwork in progress.\r\n\r\nTODO:\r\n\r\n\r\n5/17:\r\n     Initial port of circle marketplace looks good. I'm still doing some debugging on weirdness that didn't port over correctly.\r\n5/22:\r\n     Fixed some weird synchronization issues that caused payoffs to be calculated differently for each player\r\n", "experimenter": 1, "admin_html": "<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n  <head>\r\n\t\t<title>Hotelling Admin</title>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodAdmin.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n\t<body ng-controller=\"AdminCtrl\">\r\n\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>Administrator</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-md-3\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<div id=\"router-status\" class=\"alert alert-danger\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<div class=\"panel panel-default\">\r\n\t\t\t\t\t\t\t\t<div class=\"panel-body\">\r\n\t\t\t\t\t\t\t\t\t<ul class=\"nav nav-pills nav-stacked\">\r\n\t\t\t\t\t\t\t\t\t\t<li><a href=\"admin/payouts\" target=\"_blank\">View Payouts</a></li>\r\n\t\t\t\t\t\t\t\t\t\t<li><a id=\"archive\" href=\"#\">Archive Session</a></li>\r\n\t\t\t\t\t\t\t\t\t\t<li><a id=\"download\" href=\"admin/download\">Download Data</a></li>\r\n\t\t\t\t\t\t\t\t\t</ul>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"col-md-9\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<h4>Subjects</h4>\r\n\t\t\t\t\t\t\t<table class=\"table table-bordered table-condensed table-striped\">\r\n\t\t\t\t\t\t\t\t<thead>\r\n\t\t\t\t\t\t\t\t<tr><th>ID</th><th>Group</th><th>Period</th><th style=\"width: 150px;\"></th></tr>\r\n\t\t\t\t\t\t\t\t</thead>\r\n\t\t\t\t\t\t\t\t<tbody id=\"subject-list\">\r\n\t\t\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t\t\t</table>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-8\">\r\n\t\t\t\t\t\t\t<button id=\"start-session\" class=\"btn btn-success\">Start Session</button>\r\n\t\t\t\t\t\t\t<button id=\"refresh-subjects\" class=\"btn btn-info\" title=\"Attempt recover by refreshing all subject browsers\">Recover Session</button>\r\n\t\t\t\t\t\t\t<button id=\"reset-session\" class=\"btn btn-danger\">Reset Session</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div class=\"col-md-4\">\r\n\t\t\t\t\t\t\t<div class=\"pull-right\">\r\n\t\t\t\t\t\t\t\t<button id=\"pause-session\" class=\"btn btn-warning\" disabled=\"disabled\">Pause</button>\r\n\t\t\t\t\t\t\t\t<button id=\"resume-session\" class=\"btn btn-primary\" disabled=\"disabled\">Resume</button>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t<hr>\r\n\t\t\t<div class='row no-margin'>\r\n\t\t\t\t<div class=\"col-md-6\">\r\n\t\t\t\t\t<div class=\"well\">\r\n\t\t\t\t\t\t<input id=\"silo_size\" type=\"integer\" value=\"\" placeholder=\"Silo sz\" style=\"text-align: left; width:4em;\"><span id=\"silo_size\">\r\n\t\t              \t<button type=\"button\" class=\"btn btn-primary\" id=\"set_silo_size\">Set Silo Sizes</button>\r\n\t\t              \t\r\n\t\t              \t<hr>\r\n\r\n\t\t              \t<input id=\"group_size\" type=\"integer\" value=\"\" placeholder=\"Groups\" style=\"text-align: left; width:4em;\"><span id=\"group_size\">\r\n\t\t              \t<button type=\"button\" class=\"btn btn-primary\" id=\"set_group_size\">Set Group Size</button>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"col-md-6\">\r\n\t\t\t\t\t<div class=\"well\">\r\n\t\t\t\t\t\t<div id=\"current_group\"></div>\r\n\t\t              \t\r\n\t\t              \t<hr>\r\n\r\n\t\t              \t<div id='current_silo'></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t    </div>\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t<h4>Configuration</h4>\r\n\t\t\t\t\t<load-config></load-config>\r\n\t\t\t\t\t<div style=\"overflow: auto;\">\r\n\t\t\t\t\t\t<table class=\"config table table-bordered table-striped table-condensed\"></table>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n\r\n</html>\r\n", "admin_js": "  Redwood.controller(\"AdminCtrl\", [\"$rootScope\", \"$scope\", \"Admin\", function($rootScope, $scope, ra) {\r\n\r\n      var new_period = 2;\r\n      var group_size = 2;\r\n      var silo_size = 1;\r\n      var silos = [\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          [],\r\n          []\r\n      ];\r\n      var subjs = [];\r\n      $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n      $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n\r\n      var Display = { //Display controller\r\n\r\n          initialize: function() {\r\n\r\n              $(\"#start-session\").click(function() {\r\n                  $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n                  ra.trigger(\"start_session\");\r\n              });\r\n\r\n              ra.on(\"start_session\", function() {\r\n                  $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n                  $(\"#pause-session\").removeAttr(\"disabled\");\r\n              });\r\n\r\n              $(\"#refresh-subjects\").click(function() {\r\n                  $(\"#refresh-subjects\").attr(\"disabled\", \"disabled\");\r\n                  ra.refreshSubjects().then(function() {\r\n                      $(\"#refresh-subjects\").removeAttr(\"disabled\");\r\n                  });\r\n              });\r\n\r\n              $(\"#reset-session\").click(function() {\r\n                  ra.reset();\r\n              });\r\n\r\n              $(\"#pause-session\").click(function() {\r\n                  $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n                  ra.trigger(\"pause\");\r\n              });\r\n              ra.on(\"pause\", function() {\r\n                  $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n              });\r\n\r\n              $(\"#resume-session\").click(function() {\r\n                  $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n                  ra.trigger(\"resume\");\r\n              });\r\n              ra.on(\"resume\", function() {\r\n                  $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n                  $(\"#pause-session\").removeAttr(\"disabled\");\r\n              });\r\n\r\n              ra.on_subject_paused(function(userId) {\r\n                  $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n                  $(\"tr.subject-\" + userId).addClass(\"warning\"); //Display current period for each user\r\n                  $(\"tr.subject-\" + userId + \" :nth-child(4)\").text(\"Paused\"); //Display current period for each user\r\n              });\r\n\r\n              ra.on_all_paused(function() {\r\n                  $(\"#resume-session\").removeAttr(\"disabled\");\r\n              });\r\n\r\n              ra.on_subject_resumed(function(user) {\r\n                  $(\"tr.subject-\" + user).removeClass(\"warning\"); //Display current period for each user\r\n                  $(\"tr.subject-\" + user + \" :nth-child(4)\").text(\"\"); //Display current period for each user\r\n              });\r\n\r\n              $(\"#archive\").click(function() {\r\n                  var r = confirm(\"Are you sure you want to archive this session?\");\r\n                  if (r == true) {\r\n                      ra.delete_session();\r\n                  }\r\n              });\r\n\r\n              ra.on_router_connected(function(connected) { //Display router connection status\r\n        \t\t\t\tvar status = $(\"#router-status\");\r\n        \t\t\t\tif (connected) {\r\n        \t\t\t\t\tstatus.text(\"Router Connected\");\r\n        \t\t\t\t\tstatus.removeClass(\"alert-danger\");\r\n        \t\t\t\t\tstatus.addClass(\"alert-success\");\r\n        \t\t\t\t} else {\r\n        \t\t\t\t\tstatus.text(\"Router Disconnected\");\r\n        \t\t\t\t\tstatus.removeClass(\"alert-success\");\r\n        \t\t\t\t\tstatus.addClass(\"alert-danger\");\r\n        \t\t\t\t}\r\n        \t\t\t});\r\n\r\n              ra.on_set_period(function(user, period) {\r\n                  $(\"tr.subject-\" + user + \" :nth-child(3)\").text(period); //Display current period for each user\r\n              });\r\n\r\n              ra.on_set_group(function(user, group) {\r\n                  $(\"tr.subject-\" + user + \" :nth-child(2)\").text(group); //Display group for each user\r\n              });\r\n\r\n              ra.on_register(function(user) { //Add a row to the table to each user\r\n                  $(\"#subject-list\").empty();\r\n                  for (var i = 0, l = ra.subjects.length; i < l; i++) {\r\n                      $(\"#subject-list\").append($(\"<tr>\").addClass(\"subject-\" + ra.subjects[i].user_id).append(\r\n                          $(\"<td>\").text(ra.subjects[i].user_id).after(\r\n                              $(\"<td>\").text(0).after(\r\n                                  $(\"<td>\").text(0).after(\r\n                                      $(\"<td>\").text(\"\"))))));\r\n                  }\r\n              });\r\n\r\n\r\n\r\n              $(\"#set_period\").click(function() {\r\n                  if (new_period !== 0 && new_period !== undefined && new_period !== null && ra.subjects.length > 0) {\r\n                      //do_lottery();\r\n                      for (var i = 0, l = ra.subjects.length; i < l; i++) {\r\n                          ra.set_period(new_period, ra.subjects[i].user_id);\r\n                      }\r\n                      ++new_period;\r\n                  }\r\n                  $(\"#set_period\").html(\"Start Period: \" + new_period);\r\n              });\r\n\r\n              $(\"#set_group_size\").click(function() {\r\n                  group_size = Number(document.getElementById('group_size').value);\r\n\r\n                  if (group_size > 0 && group_size !== undefined && group_size !== null && !isNaN(group_size)) {\r\n                      ra.trigger(\"do_lottery\");\r\n                  }\r\n                  $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n\r\n              });\r\n\r\n              ra.on(\"do_lottery\", function() {\r\n                  setGroups = true;\r\n                  var i = 0;\r\n                  var tmp = [];\r\n\r\n                  for (var i = 0, l = ra.subjects.length; i < l; i++) {\r\n                      var subj = {};\r\n                      subj.userid = ra.subjects[i].user_id;\r\n                      subj.a = 0;\r\n                      tmp.push(subj);\r\n                  }\r\n\r\n\r\n                  var curr_group = 1;\r\n                  var count = 0;\r\n                  while (count != tmp.length) {\r\n                      var rand = Math.floor(Math.random() * (tmp.length));\r\n                      if (tmp[rand].a === 0) {\r\n                          tmp[rand].a = 1;\r\n\r\n                          ra.set_group(curr_group, tmp[rand].userid);\r\n                          count++;\r\n                          if ((count % group_size === 0) && count !== 0) curr_group++;\r\n                      }\r\n                  }\r\n              });\r\n\r\n\r\n\r\n              $(\"#set_silo_size\").click(function() {\r\n                  tmp = Number(document.getElementById('silo_size').value);\r\n                  if (tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length) {\r\n                      silo_size = Number(document.getElementById('silo_size').value);\r\n                      ra.trigger(\"set_silo\");\r\n                  } else {\r\n                      alert('Please make sure the silo size is less than or equal to the number of subjects');\r\n                  }\r\n                  $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n              });\r\n\r\n              ra.on(\"set_silo\", function() {\r\n\r\n                  tmp = Number(document.getElementById('silo_size').value);\r\n\r\n                  if (tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length) {\r\n                      silo_size = Number(document.getElementById('silo_size').value);\r\n                      subjs = [];\r\n                      silos = [\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          [],\r\n                          []\r\n                      ];\r\n\r\n                      for (var i in ra.subjects) {\r\n                          var subj = {};\r\n                          subj.id = ra.subjects[i];\r\n                          subj.a = 0;\r\n                          subj.silo = -1;\r\n                          subjs.push(subj);\r\n                      }\r\n\r\n                      var count = 0;\r\n                      var curr_silo = 0;\r\n\r\n                      while (count != subjs.length) {\r\n                          var rand = Math.floor(Math.random() * (subjs.length));\r\n                          if (subjs[rand].silo == -1) {\r\n                              subjs[rand].silo = curr_silo;\r\n\r\n                              count++;\r\n                              silos[curr_silo].push(subjs[rand]);\r\n\r\n                              if (silo_size == 1) curr_silo++;\r\n                              else if ((count % silo_size === 0) && count !== 0) curr_silo++;\r\n                          }\r\n                      }\r\n                      console.log('success setting silos. silo_size = ' + silo_size);\r\n                  }\r\n\r\n\r\n              });\r\n\r\n              ra.on_set_config(function(config) { //Display the config file\r\n                  $(\"table.config\").empty();\r\n                  var a = $.csv.toArrays(config);\r\n                  for (var i = 0; i < a.length; i++) {\r\n                      var row = a[i];\r\n                      var tr = $(\"<tr>\");\r\n                      for (var j = 0; j < row.length; j++) {\r\n                          var cell = row[j];\r\n                          var td = $((i == 0 ? \"<th>\" : \"<td>\")).text(cell);\r\n                          tr.append(td);\r\n                      }\r\n                      $(\"table.config\").append(tr);\r\n                  }\r\n              });\r\n\r\n\r\n\r\n          }\r\n      };\r\n\r\n      var resetGroups = function() {\r\n          var config = ra.get_config(1, 0) || {};\r\n          for (var i = 0; i < ra.subjects.length; i++) { //set all subjects to group 1 (this is so that matching can be changed per period)\r\n              if ($.isArray(config.groups)) {\r\n                  for (var groupId = 0; groupId < config.groups.length; groupId++) {\r\n                      if ($.isArray(config.groups[groupId])) {\r\n                          if (config.groups[groupId].indexOf(parseInt(ra.subjects[i].user_id)) > -1) { //Nested group array\r\n                              ra.set_group(groupId + 1, ra.subjects[i].user_id);\r\n                          }\r\n                      } else {\r\n                          ra.set_group(1, ra.subjects[i].user_id);\r\n                      }\r\n                  }\r\n              } else {\r\n                  ra.set_group(1, ra.subjects[i].user_id);\r\n              }\r\n          }\r\n      };\r\n\r\n\r\n\r\n      Display.initialize();\r\n\r\n      ra.on_load(function() {\r\n          resetGroups(); //Assign groups to users\r\n      });\r\n\r\n      ra.on_register(function(user) { //Add a row to the table to each user\r\n          resetGroups();\r\n      });\r\n\r\n      ra.on(\"start_session\", function() {\r\n          ra.start_session();\r\n      });\r\n\r\n      ra.on(\"pause\", function() {\r\n          ra.pause();\r\n      });\r\n\r\n      ra.on(\"resume\", function() {\r\n          ra.resume();\r\n      });\r\n\r\n\r\n\r\n\r\n  }]);", "rt_js": ""}, "model": "expecon.experiment", "pk": 18}, {"fields": {"experiment": 18, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t\t<title>Wait</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-lg-12\">\r\n\t\t\t\t\tPlease wait for experiment to start...\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Wait", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", function($rootScope, $scope, rs) {\r\n\trs.on_load(function() {\r\n\t\trs.next_period();\r\n\t});\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 124}, {"fields": {"experiment": 18, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n  <head>\r\n\t\t<title>Start</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n    <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/synchronizedStopWatch.js\"></script>\t\t\r\n    \r\n    <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.js\"></script>\r\n    <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.selection.js\"></script>\r\n    <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/d3/d3.js\"></script>\r\n    \r\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body style=\"padding-top:60px\" ng-controller=\"SubjectCtrl\">\r\n  <div class='container'>\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n        <div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n            <div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n            <ul class=\"nav navbar-nav\">\r\n                <li class=\"active\">\r\n                    <a id=\"subj\">User ID: <span>{{$root.user_id}}</span></a>\r\n                </li>\r\n            </ul>\r\n            <div class=\"navbar-right\">\r\n                <div id=\"period\" class=\"navbar-text\">Period: <span>{{$root.period}}</span></div>\r\n                <div id=\"paid\" class=\"navbar-text\">Paid: </div>\r\n                <div id=\"curr_score\" class=\"navbar-text\">Score:</div>\r\n                <div id=\"time\" class=\"navbar-text\">Time:</div>\r\n                \r\n            </div>\r\n        </div>\r\n    </div>\r\n    \r\n    <!-- Modal -->\r\n    <div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n    \r\n      <div class=\"modal-dialog\">\r\n        <div class=\"modal-content\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n  \r\n  \r\n\r\n\r\n    <div class='row'>\r\n      <div class='col-md-9'>\r\n        <div class=\"progress\" id=\"progress\">\r\n          <div id='progBar' class=\"progress-bar progress-bar-striped active\"  role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"130\" style=\"width: 0%\">\r\n            \r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div class='col-md-3'>\r\n        <h4 id = \"total_score\" style=\"visibility:hidden\">Total Score: </h4>\r\n      </div>\r\n    </div>\r\n\r\n    <div class='row'>\r\n      <h3 id=\"color\">Your color</h3>\r\n      <p id=\"x_ref\"></p>\r\n      <p id=\"y_ref\"></p> \r\n      <p id=\"x_loc\"></p>\r\n      <p id=\"test\"></p>\r\n      <h2 id=\"select\" style=\"color:red\"></h2>\r\n    </div>\r\n    <div class='row'>\r\n      <table>\r\n        <tr>\r\n          <td>\r\n            <div id=\"actionspace1\" style=\"height:400px; width:400px; margin-right:-11px;\" class=\"demo-placeholder actionspace\">  </div>\r\n          </td>\r\n          <td>\r\n            <div id=\"actionspace2\" style=\"height:400px; width:400px;\" class=\"demo-placeholder actionspace\">  </div>\r\n          </td>\r\n          <td>\r\n            <div id=\"actionspace3\" style=\"height:400px; width:400px; margin-left:-11px;\" class=\"demo-placeholder actionspace\">  </div>\r\n          </td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n    <div class='row'>\r\n      <div class=\"col-md-8 col-md-offset-4\">\r\n        <div id=\"placeholder2\" style=\"height:300px; width:420px\" class=\"demo-placeholder\">  </div>\r\n      </div>\r\n      \r\n      \r\n      <!-- rip circle marketplace \r\n      <table>\r\n        <tr>\r\n        <td>\r\n          <div class=\"demo-container\" >\r\n              <svg width=\"450\" height=\"450\" id=\"actionSpace\">\r\n                <circle id=\"actionCircle\" cx=\"225\" cy=\"225\" r=\"200\"></circle>\r\n                <circle cx=\"225\" cy=\"225\" r=\"50\" style=\"fill:black;\"></circle>\r\n              </svg>\r\n          </div>\r\n        </td>\r\n        <td style=\"padding-left: 20px\"><div class=\"demo-container\" >\r\n           <div id=\"placeholder2\" style=\"height:450px; width:450px\" class=\"demo-placeholder\">  </div>\r\n        </div></td>\r\n        </tr>\r\n      </table>\r\n      -->\r\n      \r\n    </div>\r\n  </div>\r\n</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Start", "css": "#placeholder2 {\r\n  margin-left: -15px;\r\n}\r\n\r\n#actionCircle {\r\n  fill: white;\r\n  stroke: black;\r\n}\r\n\r\n#1 {\r\n  transition: all .5s;\r\n}\r\n\r\n#2 {\r\n  transition: all .5s;\r\n}\r\n\r\n.playerCircle {\r\n  transition:-webkit-transform 0.5s, fill 0.5s;\r\n}\r\n\r\n.playerCircle:hover {\r\n  fill: steelblue;\r\n  /*-webkit-transform: scale(1.2, 1.2);*/\r\n}\r\n#hoverLine {\r\n  pointer-events: none;\r\n}\r\n\r\n.actionspace {\r\n  padding-right: 5px;\r\n}\r\n\r\n#actionspace1 .overlay {\r\n  background: -webkit-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Safari 5.1-6*/\r\n  background: -o-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Opera 11.1-12*/\r\n  background: -moz-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Fx 3.6-15*/\r\n  background: linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,1)); /*Standard*/\r\n}\r\n#actionspace3 .overlay {\r\n  background: -webkit-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Safari 5.1-6*/\r\n  background: -o-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Opera 11.1-12*/\r\n  background: -moz-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Fx 3.6-15*/\r\n  background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1)); /*Standard*/\r\n}\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", 'SynchronizedStopWatch', function($rootScope, $scope, rs, SynchronizedStopWatch) {\r\n    var id = 0; //player id\r\n    var current_period = 0;\r\n    var curr_subperiods = 1;\r\n    var num_of_players = 0; //number of players in our group\r\n    var price = 0;\r\n    var network = {}; //player object\r\n    var options; //plot 1 options\r\n    var p2_options; //plot 2 options\r\n    var player_pos = []; //location of opponent's positions\r\n    var target_pos = [0, 0]; //our current target location for continuous time\r\n    var plot;\r\n    var x_rate = 1; //percent change per second along x axis\r\n    var y_rate = 1; //percent change per second along y axis\r\n    var keeper; //game synchronizer from our group\r\n    var chosen = false; //flag\r\n    var new_loc = 0;\r\n    var new_pos = 0;\r\n    var transport_cost;\r\n    var time = 0;\r\n    var tend;\r\n    var subperiods = 0;\r\n    var paid_round = false;\r\n    var period_length = 0;\r\n    var t; //config field\r\n    var r; //redwood\r\n    var intersects = []; //array of intersect locations on x axis\r\n    var colors = ['#FF6699', '#339966', '#0066CC', '#CCA300'];\r\n    var mouse = []; //for drawing crosshairs on plot\r\n    var cummulative_payoff = 0;\r\n    var flow_payoff = []; //should be a better way of storing flow payoffs for scalability reasons..\r\n    var flow_payoff2 = [];\r\n    var game_type = \"continuous\";\r\n    var debug = false; //player 'Vs'\r\n    var debug2 = false; //intersect lines\r\n    var debug3 = false; //market share box shading\r\n    var col; //player's blue color. may be unnecessary to store this info now\r\n    var p2_t = 0; //fake time interval for plotting flow payoffs. should be changed\r\n    var flow_opts; //flow payoff debug options\r\n    var last_20 = [];\r\n    //var l = 0;\r\n    var my_pos; //player's current location and price \r\n    var sub_pay = [\r\n        [],\r\n        []\r\n    ]; //stores each player's payoffs at end of round for discrete games\r\n    var scalar_x = Number(1);\r\n    var scalar_y = Number(1);\r\n    var allow_x = 1; //discrete choosing settings\r\n    var allow_y = 0;\r\n    var price_subrounds = 1; //how many price rounds after a location round we have\r\n    var curr_sub_y = 0;\r\n    var curr_i = 0;\r\n    var p2_ticks = [];\r\n    var flag = 0; //for restarting position after new subgames\r\n    var waiting = 1; //to disable user interface\r\n    var in_group = []; //who is in my redwood group\r\n    var group_num = 0;\r\n    var silo_num = 0;\r\n    var r_debug = 0;\r\n\r\n    var myClick = [];\r\n\r\n    var total_flow = [];\r\n    var total_flow2 = [];\r\n\r\n    var filler = [0, 0]; //for making bar graphs\r\n\r\n    var quadratic = false;\r\n    var linear = true;\r\n\r\n    var payoff_mirror = 0;\r\n\r\n    var pointCounter = 0;\r\n    var myX;\r\n    var myY;\r\n    var innerRadius = 50;\r\n    var player_xy = [];\r\n\r\n    var logging = true;\r\n\r\n    function dev_log(string) {\r\n        if (logging) console.log(string);\r\n    }\r\n\r\n    /*\r\n     * returns color associated with a player\r\n     */\r\n    function player_color(key) {\r\n        for (var i = 0; i < network.players.length; ++i)\r\n            if (network.players[i].id == key) return network.players[i].color;\r\n\r\n        return '#000000';\r\n    }\r\n\r\n    /*\r\n     * returns all player's positions as x,y points\r\n     */\r\n    function get_opp_pos() {\r\n        var res = [];\r\n        for (var i = 0; i < player_pos.length; ++i) {\r\n            res.push([\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns points to draw a line on given axis to indicate where players can choose\r\n     */\r\n    function gen_targ_line(axis) {\r\n        var res = [];\r\n        if (axis == \"x\") {\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc) - 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc), 1]);\r\n        } else if (axis == \"y\") {\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0, Number(new_pos) - 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([1, Number(new_pos)]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns market boundary points for a given player to draw 'payoff area' box\r\n     */\r\n    function get_market_bounds(key) {\r\n        var res = [];\r\n        for (var i in network.players) {\r\n            if (network.players[i].id == key) {\r\n                \r\n                var player = network.players[i];\r\n\r\n                var bound_mid_lo = player.bound_mid_lo;\r\n                var bound_mid_hi = player.bound_mid_hi;\r\n\r\n                var bound_lo = player.bound_lo;\r\n                var bound_hi = player.bound_hi;\r\n\r\n                var price = player.price;\r\n\r\n\r\n                if (bound_mid_hi == -1 || bound_mid_lo == -1) {\r\n                    var out = [];\r\n                    //1 continuous payoff area\r\n                    out.push([bound_lo, null]);\r\n                    out.push([bound_lo, 0]);\r\n                    out.push([bound_lo, price]);\r\n\r\n                    out.push([bound_hi, price]);\r\n                    out.push([bound_hi, 0]);\r\n                    out.push([bound_hi, null]);\r\n                    res.push(out);\r\n\r\n                    //empty data set so we can just plot it the same way\r\n                    //this just allows flot to use res[0] and res[1] \r\n                    //for plotting different areas\r\n                    res.push([]);\r\n                } else {\r\n                    var out = [];\r\n                    //2 noncontinuous payoff areas\r\n                    out.push([bound_lo, null]);\r\n                    out.push([bound_lo, 0]);\r\n                    out.push([bound_lo, price]);\r\n\r\n                    out.push([bound_mid_lo, price]);\r\n                    out.push([bound_mid_lo, 0]);\r\n                    out.push([bound_mid_lo, null]);\r\n                    res.push(out);\r\n                    //2nd area\r\n                    out = [];\r\n                    out.push([bound_mid_hi, null]);\r\n                    out.push([bound_mid_hi, 0]);\r\n                    out.push([bound_mid_hi, price]);\r\n\r\n                    out.push([bound_hi, price]);\r\n                    out.push([bound_hi, 0]);\r\n                    out.push([bound_hi, null]);\r\n                    res.push(out);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return res;\r\n    }\r\n\r\n    var tmp_a0 = [];\r\n    var tmp_a1 = [];\r\n\r\n    //Used to hold the reflections. This is needed because Flot will try to connect\r\n    //points even if there's a break in the function, so we split up the positive\r\n    //reflections and the negative ones for both players.\r\n    var tmp_a0_front = [];\r\n    var tmp_a0_back = [];\r\n    var tmp_a1_front = [];\r\n    var tmp_a1_back = [];\r\n\r\n    var market_b = [];\r\n    var combined = true;\r\n\r\n    /*\r\n     * redraws and updates data for plot 1\r\n     */\r\n    function update_plot() {\r\n        if (waiting) return;\r\n\r\n        sort_players();\r\n\r\n        get_players();\r\n        //updateCircle();\r\n\r\n        if (combined) {\r\n            updateActionspace();\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n     * payoff debug \"V\" generating function\r\n     */\r\n    function a_single(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        // x-l^2+p\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n            var y = p + Math.abs(l + x);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function a_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x < 2.5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -2.5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x < 2.5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -2.5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n\r\n        return res;\r\n    }\r\n\r\n    function updateActionspace() {\r\n\r\n        var tmp = [target_pos];\r\n        var i = get_index_by_id(id);\r\n        var tmp_col = '#C7C7C7';\r\n\r\n        if (game_type == \"continuous\") {\r\n            targ_line = [];\r\n            my_pos = [\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ];\r\n        } else if (game_type != \"continuous\") {\r\n            var axis = \"\";\r\n            if (allow_x && !allow_y) axis = \"x\";\r\n            else if (!allow_x && allow_y) axis = \"y\";\r\n\r\n            tmp_col = '#B20000';\r\n            targ_line = gen_targ_line(axis); //draw axis choosing line if in discrete time\r\n        }\r\n\r\n        tmp_a0 = [];\r\n        tmp_a1 = [];\r\n\r\n        //Used to hold the reflections. This is needed because Flot will try to connect\r\n        //points even if there's a break in the function, so we split up the positive\r\n        //reflections and the negative ones for both players.\r\n        tmp_a0_front = [];\r\n        tmp_a0_back = [];\r\n        tmp_a1_front = [];\r\n        tmp_a1_back = [];\r\n\r\n        market_b = [];\r\n        intersects = [0, mouse[0], 1];\r\n\r\n        var opp_pos = get_opp_pos();\r\n        //This isn't done for n players -- only players 0 & 1\r\n\r\n        if (debug1) { // display payoff debug options, player \"V's\"\r\n            //if we're doing linear, use linear v generator, otherwise do quad\r\n            if (linear) {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = a_mirror(0);\r\n                    tmp_a1 = a_mirror(1);\r\n                } else {\r\n                    tmp_a0 = a_single(0);\r\n                    tmp_a1 = a_single(1);\r\n                }\r\n            } else {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = quad_mirror(0);\r\n                    tmp_a1 = quad_mirror(1);\r\n                } else {\r\n                    tmp_a0 = quad(0);\r\n                    tmp_a1 = quad(1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (debug2) { //market intersection lines\r\n            intersects = find_intersect_pts();\r\n            intersects[num_of_players + 1] = mouse[0];\r\n            options.xaxis.ticks = intersects;\r\n        }\r\n\r\n        if (debug3) { //payoff area shading\r\n            market_b = get_market_bounds(id);\r\n            if (payoff_mirror) {\r\n                //market_b_2 = get_market_bounds2(id);\r\n            }\r\n            \r\n        }\r\n        options.xaxis.ticks = intersects;\r\n        var divs = [\"#actionspace1\", \"#actionspace2\", \"#actionspace3\"];\r\n        \r\n        for (var i = 0; i < divs.length; i++) {\r\n            plot = $.plot(divs[i], [{\r\n                data: opp_pos[0],\r\n                /*hoverable: false,*/\r\n                color: player_pos[0][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[0][2]\r\n                }\r\n            }, {\r\n                data: opp_pos[1],\r\n                color: player_pos[1][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[1][2]\r\n                }\r\n            }, {\r\n                data: targ_line,\r\n                color: '#000000',\r\n                lines: {\r\n                    show: true,\r\n                    fill: false\r\n                }\r\n            }, {\r\n                data: tmp,\r\n                color: tmp_col,\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: tmp_col\r\n                }\r\n            }, {\r\n                data: tmp_a0,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: my_pos,\r\n                color: '#000000',\r\n                points: {\r\n                    show: true,\r\n                    radius: 5,\r\n                    fill: true,\r\n                    fillColor: '#0099FF'\r\n                }\r\n            }, {\r\n                data: market_b[0],\r\n                color: col,\r\n                lines: {\r\n                    show: true,\r\n                    fill: 0.25\r\n                }\r\n            }, {\r\n                data: market_b[1],\r\n                color: col,\r\n                lines : {\r\n                    show: true,\r\n                    fill: 0.25\r\n                }\r\n            }], options);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function updateCircle() {\r\n\r\n        buildProjections();\r\n\r\n        for (i = 0; i < network.players.length; i++) {\r\n            var front = network.players[i].front_projection;\r\n            var back = network.players[i].back_projection;\r\n\r\n            var playerId = network.players[i].id;\r\n\r\n\r\n            drawLineForDataSet(front, playerId, \"front\");\r\n            drawLineForDataSet(back, playerId, \"back\");\r\n            dev_log(\"rs:\" + rs.user_id + \" playerid:\" + playerId);\r\n            //This makes sure we only draw payoff shading for ourselves\r\n            if (rs.user_id == playerId) {\r\n                drawPayoffShading(network.players[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawPayoffShading(player) {\r\n        var idStr = \"shading\" + player.id;\r\n        var selector = \"#shading\" + player.id;\r\n        if (!player.valid) {\r\n            if ($(selector).exists()) {\r\n                $(selector).remove();\r\n            }\r\n            return;\r\n        }\r\n        var precision = 0.01;\r\n        var svg = d3.select(\"#actionSpace\");\r\n\r\n\r\n        var pts = [];\r\n        if (!player.disjoint_areas) {\r\n            //this constructs our payoff area rectangle\r\n            for (var i = player.bound_hi; i >= player.bound_lo; i -= precision) { pts.push([i, player.price]); }\r\n            pts.push([player.bound_lo, player.price]);\r\n            pts.push([player.bound_lo, 0]);\r\n            for (var i = player.bound_lo; i <= player.bound_hi; i += precision) { pts.push([i, 0]); }\r\n            pts.push([player.bound_hi, 0]);\r\n            pts.push([player.bound_hi, player.price]);\r\n        } else {\r\n            //Since we are drawing on the circle, we can simply draw past 1 and\r\n            //the radians conversion later will take care of it\r\n            var new_hi = 1 + player.bound_mid_lo;\r\n            var new_lo = player.bound_mid_hi;\r\n\r\n            pts.push([new_lo, player.price]);\r\n            pts.push([new_lo, 0]);\r\n\r\n            for (var i = new_lo; i <= new_hi; i += precision) { pts.push([i, 0]); }\r\n            pts.push([new_hi, 0]);\r\n\r\n            pts.push([new_hi, player.price]);\r\n            for (var i = new_hi; i >= new_lo; i -= precision) { pts.push([i, player.price]); }\r\n\r\n        }\r\n        var circle_pts = pt_to_circle(pts);\r\n        var lineFunction = d3.svg.line()\r\n            .x(function(d) {\r\n                return d.x;\r\n            })\r\n            .y(function(d) {\r\n                return d.y;\r\n            })\r\n            .interpolate(\"linear\");\r\n\r\n\r\n        dev_log(\"payoff shading points for player\" + player.id);\r\n        dev_log(pts);\r\n\r\n        if ($(selector).exists()) {\r\n            svg.select(selector)\r\n                .attr(\"d\", lineFunction(circle_pts));\r\n        } else {\r\n            var lineGraph = svg.append(\"path\")\r\n                .attr(\"id\", idStr)\r\n                .attr(\"d\", lineFunction(circle_pts))\r\n                .attr(\"stroke\", color)\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"blue\");\r\n        }\r\n    }\r\n\r\n    function drawLineForDataSet(pts, pid, dir) {\r\n        var color = getColorFromId(pid);\r\n\r\n        if (pts == null) return;\r\n\r\n        var lineFunction = d3.svg.line()\r\n            .x(function(d) {\r\n                return d.x;\r\n            })\r\n            .y(function(d) {\r\n                return d.y;\r\n            })\r\n            .interpolate(\"basis-open\");\r\n\r\n        var idStr = \"proj\" + pid + dir;\r\n        var selector = \"#proj\" + pid + dir;\r\n\r\n        var svg = d3.select(\"#actionSpace\");\r\n\r\n        //if this projection has been drawn, simply update the data\r\n        //otherwise we have to append the line to the svg\r\n        if ($(selector).exists()) {\r\n            svg.select(selector)\r\n                .attr(\"d\", lineFunction(pts));\r\n\r\n        } else {\r\n            var lineGraph = svg.append(\"path\")\r\n                .attr(\"id\", idStr)\r\n                .attr(\"d\", lineFunction(pts))\r\n                .attr(\"stroke\", color)\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"none\");\r\n        }\r\n    }\r\n    function getColorFromId(id) {\r\n        for (var i = 0; i < network.players.length; i++) {\r\n            if (network.players[i].id == id) {\r\n                return network.players[i].color;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function buildProjections() {\r\n        for (i = 0; i < network.players.length; i++) {\r\n            var player = network.players[i];\r\n            player.projection = [];\r\n            player.front_projection = [];\r\n            player.back_projection = [];\r\n\r\n            if (linear) {\r\n                player.front_projection = linear_proj(i, 1);\r\n                player.back_projection = linear_proj(i, -1);\r\n            } else if (quad) {\r\n                player.front_projection = quad_proj(i, 1);\r\n                player.back_projection = quad_proj(i, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* returns a set of data for given player that is half way in the direction of flag */\r\n    function linear_proj(index, flag) {\r\n            var res = [];\r\n            var player = network.players[index];\r\n            if (player === null || player === undefined) return res;\r\n            if (player.loc == 0) return;\r\n            var l = player.loc * -1;\r\n            var p = player.price;\r\n\r\n            if (flag == 1) {\r\n\r\n                for (var x = -3; x <= player.loc; x = x + 0.01) {\r\n                    var y = p + Math.abs(l + x);\r\n                    res.push([x, y]);\r\n                }\r\n\r\n                var closex = player.loc - .0001;\r\n                var payz = p + Math.abs(l + closex);\r\n                res.push([closex, y]);\r\n            } else {\r\n\r\n                for (var x = player.loc; x < 3; x = x + 0.01) {\r\n\r\n                    var y = p + Math.abs(l + x);\r\n                    res.push([x, y]);\r\n                }\r\n                var closex = player.loc + .0001;\r\n                var payz = p + Math.abs(l + closex);\r\n                res.push([closex, y]);\r\n            }\r\n            res = pt_to_circle(res);\r\n\r\n\r\n\r\n\r\n            return res;\r\n        }\r\n        /* returns a set of data for given player that is half way in the direction of flag */\r\n    function quad_proj(index, flag) {\r\n\r\n    }\r\n\r\n    function drawActionspace() {\r\n        var svg = d3.select(\"#actionSpace\");\r\n\r\n        //appends the circle to block position\r\n        svg.append(\"circle\")\r\n            .style(\"stroke\", \"gray\")\r\n            .style(\"fill\", \"black\")\r\n            .attr(\"r\", 50)\r\n            .attr(\"cx\", 225)\r\n            .attr(\"cy\", 225);\r\n\r\n        //appends actionSpace\r\n        svg.append(\"circle\")\r\n            .attr(\"id\", \"actionCircle\")\r\n            .style(\"stroke\", \"gray\")\r\n            .style(\"fill\", \"white\")\r\n            .attr(\"stroke-width\", 3)\r\n            .attr(\"r\", 200)\r\n            .attr(\"cx\", 225)\r\n            .attr(\"cy\", 225);\r\n    }\r\n\r\n    function resetSvg() {\r\n        clearSvg();\r\n        drawActionspace();\r\n    }\r\n\r\n    function clearSvg() {\r\n        $(\"#actionSpace\").empty();\r\n    }\r\n\r\n    //this is a helper function for checking whether or not a\r\n    //DOM element exists\r\n\r\n    jQuery.fn.exists = function(){return this.length>0;}\r\n\r\n\r\n    var date = 0;\r\n    var old_date = 0;\r\n\r\n    /*\r\n     * rewdraw and update flow payoff plot\r\n     */\r\n    function update_plot2() {\r\n        if (waiting) return;\r\n\r\n        if (game_type == \"continuous\") {\r\n            //make sure everyone is sorted\r\n            sort_players();\r\n            find_intersect_pts();\r\n\r\n            //so we can get the correct payoffs\r\n            /*\r\n            var index = get_index_by_id(id);\r\n            var pay = payoff(index);\r\n            rs.send(\"update_payoff\", {\r\n                pay: pay,\r\n                index: index\r\n            });\r\n            */\r\n\r\n            //let's find how long it was since we updated our payoffs      \r\n            date = new Date();\r\n            date.getTime();\r\n\r\n            var d = date - old_date;\r\n            old_date = date;\r\n\r\n            p2_t += 0.12;\r\n            //p2_t += d;\r\n\r\n            cummulative_payoff += network.players[get_index_by_id(id)].payoff * (d / (period_length * 1000));\r\n\r\n            document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n            if (flow_opts == \"all\") {\r\n                //push all player's data to be plotted\r\n                flow_payoff.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                flow_payoff2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                total_flow.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                total_flow2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                //add extra white space to front of plot to hide end time\r\n                p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                last_20.push(network.players[get_index_by_id(in_group[0])].payoff);\r\n                last_20.push(network.players[get_index_by_id(in_group[1])].payoff);\r\n\r\n                //get rid of data more than 20seconds old\r\n                if (time >= 20) {\r\n                    flow_payoff.shift();\r\n                    flow_payoff2.shift();\r\n                    last_20.shift();\r\n                    p2_options.xaxis.min = flow_payoff[0][0];\r\n                }\r\n\r\n                //scale flow payoff y axis to fit m ax payoff during the last 20 seconds \r\n                p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                plot2 = $.plot(\"#placeholder2\", [{\r\n                    data: flow_payoff,\r\n                    color: player_color(network.players[get_index_by_id(in_group[0])].id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    }\r\n                }, {\r\n                    data: flow_payoff2,\r\n                    color: player_color(network.players[get_index_by_id(in_group[1])].id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    }\r\n                }], p2_options);\r\n\r\n            } else if (flow_opts == \"own\") {\r\n                //in this case we only plot our own payoff data\r\n                flow_payoff.push([p2_t, network.players[get_index_by_id(id)].payoff]);\r\n                total_flow.push([p2_t, network.players[0].payoff]);\r\n\r\n                last_20.push(network.players[get_index_by_id(id)].payoff);\r\n                p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                if (time >= 20) {\r\n                    flow_payoff.shift();\r\n                    last_20.shift();\r\n                    p2_options.xaxis.min = flow_payoff[0][0];\r\n                }\r\n\r\n                p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                plot2 = $.plot(\"#placeholder2\", [{\r\n                    data: flow_payoff,\r\n                    color: player_color(id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    }\r\n                }], p2_options);\r\n\r\n            } else if (flow_opts == \"none\") {\r\n                //otherwise we plot nothing\r\n                return;\r\n            }\r\n\r\n        } else {\r\n            //else we are in discrete time\r\n            p2_options.xaxis.tickDecimals = 0;\r\n            p2_options.xaxis.min = 0;\r\n            p2_options.xaxis.max = curr_subperiods + 2;\r\n            p2_options.xaxis.ticks = p2_ticks;\r\n\r\n            if (flow_opts == \"all\") {\r\n                flow_payoff = plot_data(sub_pay[0], 0, 1);\r\n                flow_payoff2 = plot_data(sub_pay[1], 0, 1);\r\n\r\n                //set player's payoff bar graphs to have 25% opacity\r\n                if (network.players[0].id == id) filler = [0.25, 0];\r\n                else if (network.players[1].id == id) filler = [0, 0.25];\r\n\r\n                plot2 = $.plot(\"#placeholder2\", [{\r\n                    data: flow_payoff,\r\n                    color: player_color(network.players[0].id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    },\r\n                    lines: {\r\n                        fill: filler[0]\r\n                    }\r\n                }, {\r\n                    data: flow_payoff2,\r\n                    color: player_color(network.players[1].id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    },\r\n                    lines: {\r\n                        fill: filler[1]\r\n                    }\r\n                }], p2_options);\r\n\r\n            } else if (flow_opts == \"own\") {\r\n\r\n                flow_payoff = plot_data(sub_pay[get_index_by_id(id)], 0, 1);\r\n\r\n                plot2 = $.plot(\"#placeholder2\", [{\r\n                    data: flow_payoff,\r\n                    color: player_color(id),\r\n                    points: {\r\n                        show: false,\r\n                        radius: 4,\r\n                        fill: true,\r\n                        fillColor: '#C7C7C7'\r\n                    },\r\n                    lines: {\r\n                        fill: 0.25\r\n                    }\r\n                }], p2_options);\r\n                return;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * nicely package flow payoff data for discrete time types\r\n     * div is now always 1 since lines should overlap\r\n     */\r\n    function plot_data(input, offset, div) {\r\n        var res = [];\r\n        var i = 0;\r\n        p2_ticks = [];\r\n        for (var a in input) {\r\n            if (input[a] !== 0) {\r\n                res.push([i + ((1 / div) * offset), null]);\r\n                res.push([i + ((1 / div) * offset), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), null]);\r\n                p2_ticks.push(i);\r\n                i++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * default\r\n     */\r\n    function linear_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(network.players[pos].loc - network.players[i].loc) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * d^2 * t\r\n     */\r\n    function quadratic_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(Math.pow(network.players[pos].loc - network.players[i].loc), 2) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * find only players that have a market share\r\n     */\r\n    function validate_players() {\r\n        var tmp = network.players;\r\n        var res = [];\r\n        //var index;\r\n        var i;\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var p1 = network.players[i];\r\n            tmp[i].valid = 1;\r\n\r\n            for (var j = 0; j < network.players.length; ++j) {\r\n                var p2 = network.players[j];\r\n\r\n                //for every player excluding yourself compare price\r\n                if (i != j) {\r\n                    if (linear) {\r\n                        \r\n                        //new system for circle determines validity based on where intersects occur\r\n                        var intersect1 = (t * (p2.loc + p1.loc) + (p2.price - p1.price)) / (2 * t);\r\n                        var intersect2 = (t * (p2.loc + p1.loc + 1) - (p2.price - p1.price)) / (2 * t);\r\n                        var intersect3 = (t * (p2.loc + p1.loc - 1) + (p1.price - p2.price)) / (2 * t);\r\n\r\n                        if (p1.price > p2.price + t * Math.abs(p1.loc - p2.loc)) {\r\n                            tmp[i].valid = 0;\r\n\r\n                            network.players[i].bound_lo = 0;\r\n                            network.players[i].bound_hi = 0;\r\n                            network.players[i].bound_mid_hi = 0;\r\n                            network.players[i].bound_mid_lo = 0;\r\n\r\n                        } \r\n\r\n                        //mirrored case\r\n                        if (p1.price > p2.price + t * Math.abs(p1.loc - p2.loc - 1)) {\r\n                            tmp[i].valid = 0;\r\n\r\n                            network.players[i].bound_lo = 0;\r\n                            network.players[i].bound_hi = 0;\r\n                            network.players[i].bound_mid_hi = 0;\r\n                            network.players[i].bound_mid_lo = 0;\r\n                        }\r\n                        //mirrored case 2\r\n                        if (p1.price > p2.price + t * Math.abs(p1.loc - p2.loc + 1)) {\r\n                            tmp[i].valid = 0;\r\n\r\n                            network.players[i].bound_lo = 0;\r\n                            network.players[i].bound_hi = 0;\r\n                            network.players[i].bound_mid_hi = 0;\r\n                            network.players[i].bound_mid_lo = 0;\r\n                        }\r\n\r\n                    } else if (quadratic) {\r\n                        var intersection = (Math.pow(p1.loc, 2) - Math.pow(p2.loc, 2) + p1.price - p2.price) / (2 * Math.abs(p1.loc - p2.loc));\r\n                        intersection = Math.abs(intersection);\r\n\r\n                        var priceScalar = p2.price + t * Math.pow(p1.loc - p2.loc, 2);\r\n\r\n                        //If the intersection occurs less than 0 or above 1, the player with the lower price `wins`\r\n                        if (!((0 < intersection) && (intersection < 1))) {\r\n\r\n                            if (p1.price > p2.price) {\r\n                                tmp[i].valid = 0;\r\n\r\n                                //update player's new market bounds\r\n                                var new_lo_bound = 0;\r\n                                var new_hi_bound = 0;\r\n\r\n                                network.players[i].bound_lo = new_lo_bound;\r\n                                network.players[i].bound_hi = new_hi_bound;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            if (tmp[i].valid == 1) res.push(network.players[i]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    /*\r\n     * returns array of all points along x-axis that correspond to an intersection\r\n     */\r\n    function find_intersect_pts() {\r\n        var res = [];\r\n        res.push(0);\r\n\r\n        var tmp = validate_players();\r\n        var i;\r\n\r\n\r\n        //high = [i+1], low = [i]\r\n        if (linear) {\r\n\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n                var intersect1 = (t * (tmp[i + 1].loc + tmp[i].loc) + (tmp[i + 1].price - tmp[i].price)) / (2 * t);\r\n\r\n                //res.push(intersect1);\r\n\r\n                if (payoff_mirror) {\r\n                    var intersect2 = (t * (tmp[i + 1].loc + tmp[i].loc + 1) - (tmp[i + 1].price - tmp[i].price)) / (2 * t);\r\n                    var intersect3 = (t * (tmp[i + 1].loc + tmp[i].loc - 1) + (tmp[i].price - tmp[i+1].price)) / (2 * t);\r\n                    \r\n\r\n                    //this makes sure intersections are pushed in the correct order\r\n                    if (intersect2 > 1) {\r\n                        if (intersect3 < intersect1) {\r\n                            res.push(intersect3);\r\n                            res.push(intersect1);\r\n                        } else {\r\n                            res.push(intersect1);\r\n                            res.push(intersect3);\r\n                        }\r\n                    } else {\r\n                        if (intersect2 < intersect1) {\r\n                            res.push(intersect2);\r\n                            res.push(intersect1);\r\n                        } else {\r\n                            res.push(intersect1);\r\n                            res.push(intersect2);\r\n                        }\r\n                    }\r\n                    \r\n\r\n                }\r\n            }\r\n\r\n\r\n        } else if (quad) {\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n\r\n                //Let's recreate the lower player on the left and right side of the boundaries\r\n                if (payoff_mirror) {\r\n                    var loc_low_one = tmp[i].loc + 1;\r\n                    var loc_low_zero = tmp[i].loc - 1;\r\n                }\r\n                var loc_low = tmp[i].loc;\r\n                var price_low = tmp[i].price;\r\n                var loc_high = tmp[i + 1].loc;\r\n                var price_high = tmp[i + 1].price\r\n\r\n                //this calculates the intersections between two quadratics\r\n                var top = (Math.pow(loc_high, 2) - Math.pow(loc_low, 2) + price_high - price_low);\r\n                var denom = (2 * Math.abs(loc_high - loc_low));\r\n                var intersection = top / denom;\r\n\r\n                //grab our inital intersection\r\n                if (intersection < 0 || intersection > 1) {\r\n                    res.push(0);\r\n                } else {\r\n                    res.push(intersection);\r\n                }\r\n                //lets grab our mirrored intersections\r\n                if (payoff_mirror) {\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored above 1\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_one, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_one));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored below 0\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_zero, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_zero));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        res.push(1);\r\n       \r\n\r\n    \r\n        var new_lo_bound;\r\n\r\n        var new_hi_bound;\r\n        var index;\r\n\r\n        //this loop will determine which player has a disjoint payoff area\r\n        for (i = 0; i < tmp.length; i++) {\r\n            \r\n            index = get_index_by_id(tmp[i].id);\r\n\r\n            var player = network.players[index];\r\n            var player_loc = player.loc;\r\n            //if there are intersections between 0 and 1\r\n            if (res.length >= 4) {\r\n\r\n                new_lo_bound = res[0];\r\n                new_mid_lo = res[1];\r\n                new_mid_hi = res[2];\r\n                new_hi_bound = res[3];\r\n\r\n                if (player_loc > new_mid_lo && player_loc < new_mid_hi) {\r\n                    player.disjoint_areas = 0;\r\n                } else {\r\n                    player.disjoint_areas = 1;\r\n                }\r\n\r\n\r\n            } else {\r\n               player.disjoint_areas = 0;\r\n            }\r\n        }\r\n\r\n\r\n        for (i = 0; i < tmp.length; ++i) {\r\n\r\n            new_lo_bound = res[i];\r\n            new_hi_bound = res[i + 1];\r\n            index = get_index_by_id(tmp[i].id);\r\n\r\n            if (res.length >= 4) {\r\n\r\n                new_lo_bound = res[0];\r\n                new_mid_lo = res[1];\r\n                new_mid_hi = res[2];\r\n                new_hi_bound = res[3];\r\n\r\n\r\n                if (tmp[i].disjoint_areas) {\r\n                    //this player will have two payoff areas, broken in the middle by the next players\r\n                    //area\r\n                    network.players[index].bound_lo = new_lo_bound;\r\n                    network.players[index].bound_mid_lo = new_mid_lo;\r\n\r\n                    network.players[index].bound_mid_hi = new_mid_hi;\r\n                    network.players[index].bound_hi = new_hi_bound;\r\n                } else {\r\n                    network.players[index].bound_lo = new_mid_lo;\r\n                    network.players[index].bound_hi = new_mid_hi;\r\n\r\n                    //this player has only one continuous payoff area\r\n                    network.players[index].bound_mid_hi = -1;\r\n                    network.players[index].bound_mid_lo = -1;\r\n                }\r\n            } else {\r\n\r\n                //this is the case where one player holds the entire area\r\n                network.players[index].disjoint_areas = 0;\r\n                \r\n                network.players[index].bound_lo = new_lo_bound;\r\n                network.players[index].bound_hi = new_hi_bound;\r\n\r\n                //this player has only one continuous payoff area\r\n                network.players[index].bound_mid_hi = 0;\r\n                network.players[index].bound_mid_lo = 0;\r\n            }\r\n            \r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * payoff = market_share * price\r\n     */\r\n    function payoff(index) {\r\n        var player = network.players[index];\r\n        var bound_lo = player.bound_lo;\r\n        var bound_hi = player.bound_hi;\r\n\r\n        var bound_mid_lo = player.bound_mid_lo;\r\n        var bound_mid_hi = player.bound_mid_hi;\r\n\r\n\r\n        if (bound_mid_hi == -1 || bound_mid_lo == -1) {\r\n            var market_share = Math.abs(bound_hi - bound_lo) * scalar_x;\r\n        } else {\r\n            var market_share = (Math.abs(bound_mid_lo - bound_lo) + Math.abs(bound_hi - bound_mid_hi)) * scalar_x;\r\n        }\r\n\r\n        return market_share * (network.players[index].price * scalar_y);\r\n    }\r\n\r\n    /*\r\n     * sorts players in descending order. bubblesort\r\n     */\r\n    function sort_players() {\r\n        var grp = network.players;\r\n        var len = network.players.length;\r\n\r\n        for (var i = 0; i < len - 1; ++i) {\r\n            for (var j = 0; j < ((len - 1) - i); ++j) {\r\n                if (grp[j].loc > grp[j + 1].loc) {\r\n                    var tmp = grp[j + 1];\r\n                    grp[j + 1] = grp[j];\r\n                    grp[j] = tmp;\r\n                }\r\n            }\r\n        }\r\n\r\n        network.players = grp;\r\n    }\r\n\r\n    /*\r\n     * returns index in network object array of player with id 'key'\r\n     */\r\n    function get_index_by_id(key) {\r\n        var res = -1;\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (network.players[i].id == key) return i;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    //This takes the subject ID string and does a regex lookup to determine which subject number they are\r\n    function get_subject_num_by_id(key) {\r\n        return key.match(/\\d+/)[0];\r\n    }\r\n\r\n    function get_players() {\r\n        if(waiting) return;\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            player_pos[i] = [network.players[i].loc, network.players[i].price, network.players[i].color];\r\n        }\r\n    }\r\n\r\n    function log_data() {\r\n        if (id == keeper) {\r\n            var value = network.players;\r\n            rs.send(\"data_log\", {\r\n                value: value,\r\n                curr_subperiods: curr_subperiods,\r\n                silo_num: silo_num\r\n            });\r\n        }\r\n    }\r\n\r\n    //x and y are bounded between 0 and 1\r\n    //maps to a point (x, y) on the circle corresponding to this\r\n    function map_point_to_circle(point) {\r\n        var x = point[0];\r\n        var y = point[1];\r\n\r\n        var rad = 50 + (150 * y);\r\n        var theta = x * 2 * Math.PI;\r\n\r\n\r\n        var new_x = rad * (Math.cos(-theta)) + 225;\r\n        var new_y = rad * (Math.sin(-theta)) + 225;\r\n\r\n        return [new_x, new_y, theta];\r\n    }\r\n\r\n    function point_to_circle(point) {\r\n        var x = point[0];\r\n        var y = point[1];\r\n\r\n        var rad = 50 + (150 * y);\r\n        var theta = x * 2 * Math.PI;\r\n\r\n\r\n        var new_x = rad * (Math.cos(-theta)) + 225;\r\n        var new_y = rad * (Math.sin(-theta)) + 225;\r\n        return {\r\n            \"x\": new_x,\r\n            \"y\": new_y\r\n        };\r\n    }\r\n\r\n    function pt_to_circle(points) {\r\n        var new_pts = [];\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i];\r\n            var obj = point_to_circle(point);\r\n\r\n            var checkx = obj[\"x\"];\r\n            var checky = obj[\"y\"];\r\n\r\n            var relX = Math.pow(checkx - 225, 2);\r\n            var relY = Math.pow(checky - 225, 2);\r\n\r\n            var distance = Math.sqrt(relX + relY);\r\n\r\n            if (distance >= 200) continue;\r\n            // console.log(obj);\r\n            new_pts.push(obj);\r\n        }\r\n        return new_pts;\r\n    }\r\n\r\n    //time keeping 1s interval function\r\n    function tick() {\r\n        dev_log(network.players);\r\n        dev_log(rs);\r\n        if (waiting) return;\r\n\r\n        if (time <= 1) {\r\n            $(\".period\").HTML = \"Period: \" + rs.period;\r\n            network.players[get_index_by_id(id)].color = col;\r\n        }\r\n\r\n        // generate random player clicks if debug option is set\r\n        if (r_debug) {\r\n            new_loc = Math.random().toFixed(3);\r\n            new_pos = Math.random().toFixed(3);\r\n            var iterx = 0;\r\n            var itery = 0;\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n\r\n            target_pos = [Number(new_loc), Number(new_pos)];\r\n            rs.send(\"update_target\", {\r\n                new_loc: new_loc,\r\n                new_pos: new_pos,\r\n                id: id\r\n            });\r\n        }\r\n\r\n        time = time + 1;\r\n\r\n        // hope to fix any weird color overriding at start... \r\n        if (time == 5) {\r\n            for (var n in network.players) {\r\n                if (network.players[n].color == '#0066FF' && network.players[n].id != id)\r\n                    network.players[n].color = colors[1];\r\n            }\r\n        }\r\n\r\n        if (game_type == \"stage\") {\r\n            var width = ((250 / (period_length / subperiods)) * time) % 250;\r\n            $('#progBar').css('width', width + \"%\");\r\n        } else {\r\n            var width = (250 / period_length) * time;\r\n            $('#progBar').css('width', width + \"%\");\r\n        }\r\n\r\n        \r\n\r\n        //check for end of period in continous time\r\n        if (time >= period_length) {\r\n            if (id == keeper) rs.send(\"new_period\", {\r\n                current_period: current_period\r\n            });\r\n        }\r\n\r\n        if (game_type == \"simultaneous\") {\r\n            sub_pay[0][curr_subperiods - 1] = network.players[0].payoff.toFixed(2);\r\n            sub_pay[1][curr_subperiods - 1] = network.players[1].payoff.toFixed(2);\r\n\r\n            cummulative_payoff = 0;\r\n            for (i = 0; i < sub_pay[get_index_by_id(id)].length; ++i) {\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n            }\r\n\r\n            if (time % (period_length / subperiods) === 0) {\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_loc\", {\r\n                    new_loc: new_loc,\r\n                    id: id,\r\n                    iterx: iterx\r\n                });\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"new_subperiod\", {\r\n                        curr_subperiods: curr_subperiods\r\n                    });\r\n\r\n                    if (curr_subperiods == subperiods) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n            }\r\n        } else if (game_type == \"stage\") {\r\n\r\n            if (allow_x && !allow_y) document.getElementById(\"select\").innerHTML = \"Choose x\";\r\n            else if (!allow_x && allow_y) document.getElementById(\"select\").innerHTML = \"Choose y\";\r\n\r\n            if (allow_x && !flag) { //reset price at beginning of new subgame and keep old location\r\n                //new_pos = 0;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n                flag = 1;\r\n            }\r\n\r\n            if (time % (period_length / subperiods) < 1) { //at the end of every subperiod update new position on plot\r\n                console.log(\"ENDING SUBPERIOD\");\r\n                curr_i += 4;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                var offset = 1 / num_of_players;\r\n\r\n                if (allow_x) {\r\n\r\n                    rs.send(\"update_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    allow_x = 0;\r\n                    allow_y = 1; //switch to price subrounds\r\n\r\n                } else if (allow_y) {\r\n                    rs.send(\"update_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n\r\n                    ++curr_sub_y;\r\n\r\n                    if (curr_sub_y == price_subrounds) { //when we reach the last price subround, start a new subgame\r\n                        if (id == keeper) rs.send(\"set_payoffs\", {\r\n                            curr_subperiods: curr_subperiods,\r\n                            id: id\r\n                        });\r\n                        sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                        sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n\r\n                        allow_x = 1;\r\n                        allow_y = 0;\r\n\r\n                        if (id == keeper) rs.send(\"update_subsetting\", {\r\n                            allow_x: allow_x,\r\n                            allow_y: allow_y,\r\n                            curr_sub_y: curr_sub_y\r\n                        });\r\n\r\n                    }\r\n\r\n                    if (curr_sub_y == 2) {\r\n                        sub_pay[0].shift();\r\n                        sub_pay[1].shift();\r\n                    }\r\n                }\r\n\r\n                if (id == keeper) rs.send(\"new_subperiod\", {\r\n                    curr_subperiods: curr_subperiods\r\n                });\r\n\r\n                if (curr_subperiods == subperiods) { //when we go through all subperiods, it's time for a new period\r\n                    sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                    sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n                    if (id == keeper) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"update_subsetting\", {\r\n                        allow_x: allow_x,\r\n                        allow_y: allow_y,\r\n                        curr_sub_y: curr_sub_y\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        calculatePayoffs();\r\n\r\n        var i;\r\n\r\n        intersects = find_intersect_pts();\r\n\r\n        //document.getElementById(\"total_score\").innerHTML = \"Total Score: \" + rs.points.toFixed(3);\r\n        //document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n        //save payoff at end of round\r\n        if (sub_pay[0][curr_subperiods - 1] === undefined) {\r\n            sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n        }\r\n\r\n        if (sub_pay[1][curr_subperiods - 1] === undefined) {\r\n            sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n        }\r\n\r\n        if (rs.config.show_secs_left) document.getElementById(\"time\").innerHTML = \"Time left: \" + Math.ceil(period_length - time);\r\n    }\r\n\r\n    function calculatePayoffs() {\r\n        for (i = 0; i < network.players.length; i++) {\r\n            var pay = payoff(i);\r\n            network.players[i].payoff = pay;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * function for implementing % change on x and y axes. determines if dot should continue moving or not\r\n     */\r\n    function refresh() {\r\n        if (waiting) return;\r\n\r\n        var index = get_index_by_id(id);\r\n\r\n        if ((x_rate === 0 && y_rate === 0) || game_type == \"simultaneous\" || game_type == \"stage\") {\r\n            return;\r\n        }\r\n\r\n        var iterx;\r\n        var itery;\r\n        var diffx;\r\n        var diffy;\r\n        var signx;\r\n        var signy;\r\n        var scalex;\r\n        var scaley;\r\n\r\n        if (network.players[index].loc != network.players[index].target[0]) { //while we are not at our target x position\r\n            //get difference along x\r\n            diffx = Number(network.players[index].target[0]) - Number(network.players[index].loc);\r\n\r\n            if (diffx < 0) signx = 1;\r\n            else signx = 0;\r\n\r\n            scalex = x_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffx) < (scalex * 2)) {\r\n                new_loc = Number(network.players[index].target[0]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                iterx = network.players[index].iterx - 1;\r\n                if (iterx < 0) iterx = Number(0);\r\n\r\n                //check which direction we have to move in\r\n                if (signx) new_loc = Number(network.players[index].loc) - scalex;\r\n                else new_loc = Number(network.players[index].loc) + scalex;\r\n            }\r\n\r\n            if (new_loc > 1) new_loc = 1;\r\n            else if (new_loc < 0) new_loc = 0;\r\n\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n        }\r\n\r\n        if (network.players[index].pos != network.players[index].target[1]) { //while we are not at our target y position\r\n            //get difference along y\r\n            diffy = Number(network.players[index].target[1]) - Number(network.players[index].price);\r\n\r\n            if (diffy < 0) signy = 1;\r\n            else signy = 0;\r\n\r\n            scaley = y_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffy) < (scaley * 2)) {\r\n                new_pos = Number(network.players[index].target[1]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                itery = network.players[index].itery - 1;\r\n                if (itery < 0) itery = Number(0);\r\n\r\n                if (signy) new_pos = Number(network.players[index].price) - scaley;\r\n                else new_pos = Number(network.players[index].price) + scaley;\r\n            }\r\n\r\n            if (new_loc > 1) new_pos = 1;\r\n            else if (new_loc < 0) new_pos = 0;\r\n\r\n            if (new_pos > 1) new_pos = 1;\r\n            if (new_pos < 0) new_pos = 0;\r\n\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    rs.on_load(function() {\r\n        dev_log(rs);\r\n        rs.send(\"config\", {});\r\n\r\n        id = rs.user_id;\r\n        group_num = rs._group;\r\n\r\n        for (var i = 0, l = rs.subjects.length; i < l; i++) {\r\n            in_group.push(parseInt(rs.subjects[i].user_id));\r\n        }\r\n        num_of_bidders = rs.subjects.length;\r\n        num_of_players = in_group.length;\r\n\r\n        current_period = rs.period;\r\n        time = 0;\r\n        network.players = [];\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n\r\n        $scope.clock = SynchronizedStopWatch.instance()\r\n            .frequency(1).onTick(tick)\r\n            .duration(rs.config.period_length).onComplete(function() {\r\n                rs.trigger(\"new_period\");\r\n                \r\n            });\r\n\r\n        \r\n\r\n\r\n        //setInterval(refresh, 300);\r\n        setInterval(log_data, 500);\r\n        setInterval(update_plot2, 400);\r\n        setInterval(update_plot, 30);\r\n\r\n        var svg = d3.select(\"#actionSpace\");\r\n        var player_cy = 0;\r\n        //initialize our player objects\r\n        for (var i = 0; i < num_of_players; ++i) {\r\n            var player = {};\r\n            player.loc = 0;\r\n            player.price = 0;\r\n            player.payoff = 0;\r\n\r\n            player.bound_lo = 0;\r\n            player.bound_hi = 0;\r\n            //these are used for circle marketplace, since there can be new intersections\r\n            player.bound_mid_lo = 0;\r\n            player.bound_mid_hi = 0;\r\n\r\n            //this is a flag that is set if the payoff areas for the player\r\n            //are disjoint (ie a player controlls two areas separated in the middle by the other player)\r\n\r\n            player.disjoint_areas = 0;\r\n\r\n            player.id = in_group[i];\r\n            player.valid = 1;\r\n            player.iterx = 0;\r\n            player.itery = 0;\r\n            player.target = [0, 0];\r\n            player.group = group_num;\r\n            \r\n\r\n            player.color = colors[i];\r\n\r\n            \r\n            network.players.push(player);\r\n\r\n            var playerz = {};\r\n            playerz.x_pos = 0;\r\n            playerz.y_pos = 0;\r\n            playerz.color = colors[i];\r\n            player_xy.push(player);\r\n\r\n            var thiscolor = colors[i];\r\n            var num = in_group[i];\r\n            if (id == player.id) {\r\n                thiscolor = \"#0066FF\";\r\n            }\r\n\r\n            svg.append(\"circle\")\r\n                .attr(\"id\", num)\r\n                .attr(\"class\", \"playerCircle\")\r\n                .attr(\"fill\", thiscolor)\r\n                .attr(\"cx\", 225)\r\n                .attr(\"cy\", 225 + player_cy)\r\n                .attr(\"r\", 7);\r\n\r\n            player_cy += 10;\r\n        }\r\n\r\n        \r\n        $('#myModal').modal({\r\n            backdrop: 'static',\r\n            keyboard: false\r\n        });\r\n        \r\n\r\n        var divs = [\"#actionspace1\", \"#actionspace2\", \"#actionspace3\"];\r\n        for (var i = 0; i < divs.length; i++) {\r\n            \r\n            //plot click event handler\r\n            $(divs[i]).bind(\"plotclick\", function(event, pos, item) {\r\n                if (game_type == \"stage\") {\r\n                    if (allow_x) new_loc = pos.x.toFixed(3);\r\n                    else if (allow_y) new_pos = pos.y.toFixed(3);\r\n                } else {\r\n                    new_loc = pos.x.toFixed(3);\r\n                    new_pos = pos.y.toFixed(3);\r\n                }\r\n\r\n                if (new_loc > 1) new_loc = 1;\r\n                else if (new_loc < 0) new_loc = 0;\r\n\r\n                if (new_pos > 1) new_pos = 1;\r\n                if (new_pos < 0) new_pos = 0;\r\n\r\n\r\n                //iters no longer used..\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                target_pos = [Number(new_loc), Number(new_pos)];\r\n\r\n                if (game_type == \"simultaneous\" || game_type == \"stage\") {\r\n                    my_pos = [[new_loc, new_pos]];\r\n                } else if (game_type == \"continuous\") {\r\n                    if (x_rate === 0) {\r\n                        rs.send(\"update_loc\", {\r\n                            new_loc: new_loc,\r\n                            id: id,\r\n                            iterx: iterx\r\n                        });\r\n                        rs.trigger(\"update_my_loc\", {\r\n                            new_loc: new_loc,\r\n                            id: id,\r\n                            iterx: iterx\r\n                        });\r\n                    }\r\n                    if (y_rate === 0) {\r\n                        rs.send(\"update_pos\", {\r\n                            new_pos: new_pos,\r\n                            id: id,\r\n                            itery: itery\r\n                        });\r\n                        rs.trigger(\"update_my_pos\", {\r\n                            new_pos: new_pos,\r\n                            id: id,\r\n                            itery: itery\r\n                        })\r\n                    }\r\n                    rs.send(\"update_target\", {\r\n                        new_loc: new_loc,\r\n                        new_pos: new_pos,\r\n                        id: id\r\n                    });\r\n                    rs.trigger(\"update_my_target\", {\r\n                        new_loc: new_loc,\r\n                        new_pos: new_pos,\r\n                        id: id\r\n                    });\r\n\r\n                    sort_players();\r\n                    find_intersect_pts();\r\n                    var index = get_index_by_id(id);\r\n\r\n                    var pay = payoff(index);\r\n                    rs.send(\"update_payoff\", {\r\n                        pay: pay,\r\n                        index: index\r\n                    });\r\n                    rs.trigger(\"update_my_payoff\", {\r\n                        pay: pay,\r\n                        index: index\r\n                    });\r\n                }\r\n\r\n                update_plot();\r\n            });\r\n        }\r\n        \r\n\r\n        \r\n        for (var i = 0; i < divs.length; i++) {\r\n            //plot 1 on hover event handler for drawing crosshairs\r\n            $(divs[i]).bind(\"plothover\", function(event, pos, item) {\r\n                var a, b;\r\n\r\n                if (game_type == \"stage\") {\r\n                    if (allow_x && !allow_y) {\r\n                        a = pos.x.toFixed(3);\r\n                    } else if (!allow_x && allow_y) {\r\n                        b = pos.y.toFixed(3);\r\n                    }\r\n                } else {\r\n                    a = pos.x.toFixed(3);\r\n                    b = pos.y.toFixed(3);\r\n                }\r\n\r\n                mouse = [a, b];\r\n\r\n                intersects[num_of_players + 1] = a;\r\n\r\n                options.xaxis.ticks = intersects;\r\n                options.yaxis.ticks = [0, b, 1.5];\r\n            });\r\n        }\r\n\r\n        $scope.clock.start();\r\n    });\r\n\r\n    rs.recv(\"rdebug\", function(uid, msg) {\r\n        r_debug = msg.mode;\r\n    });\r\n\r\n    rs.recv(\"data_log\", function(uid, msg) {\r\n        //intentionally blank    \r\n    });\r\n\r\n    rs.recv(\"set_payoffs\", function(uid, msg) {\r\n        intersects = find_intersect_pts();\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var pay = payoff(i);\r\n            var index = i;\r\n            rs.send(\"update_payoff\", {\r\n                pay: pay,\r\n                index: index\r\n            });\r\n        }\r\n    });\r\n\r\n    rs.recv(\"new_subperiod\", function(uid, msg) {\r\n        if (msg.curr_subperiods !== null) {\r\n            curr_subperiods = msg.curr_subperiods + 1;\r\n            cummulative_payoff = 0;\r\n\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n\r\n            document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n        } else return;\r\n    });\r\n\r\n    rs.on(\"new_period\", function(msg) {\r\n        clearInterval(log_data);\r\n        clearInterval(update_plot2);\r\n        clearInterval(update_plot);\r\n        waiting = 1;\r\n\r\n        //count up sub payoffs for total period payoff for discrete types\r\n        if (game_type != \"continuous\") {\r\n            cummulative_payoff = 0;\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n        }\r\n\r\n        if (paid_round) rs.add_points(cummulative_payoff);\r\n        document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n        $(\"#myModal\").modal('show');\r\n        rs.next_period(5);\r\n    });\r\n\r\n    rs.recv(\"update_player\", function(uid, msg) {\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(0);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_payoff\", function(uid, msg) {\r\n        \r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.on(\"update_my_payoff\", function(msg) {\r\n        \r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_bounds\", function(uid, msg) {\r\n\r\n        if (msg.new_lo_bound !== null) {\r\n            network.players[msg.index].bound_lo = msg.new_lo_bound;\r\n        }\r\n\r\n        if (msg.new_hi_bound !== null) {\r\n            network.players[msg.index].bound_hi = msg.new_hi_bound;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_iterx\", function(uid, msg) {\r\n        if (msg.iterx !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.target_x - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_itery\", function(uid, msg) {\r\n        if (msg.itery !== null) {\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.target_y - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_loc\", function(uid, msg) {\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_loc\", function(msg) {\r\n        \r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_pos\", function(uid, msg) {\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_pos\", function(msg) {\r\n        \r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n\r\n    rs.recv(\"update_target\", function(uid, msg) {\r\n        \r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n    rs.on(\"update_my_target\", function(msg) {\r\n        \r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n    /*\r\n        Circle redwood util functions\r\n    */\r\n    rs.recv(\"update_theta\", function(uid, msg) {\r\n        if (msg.theta !== null) {\r\n\r\n            var index = get_index_by_id(msg.id);\r\n\r\n            network.players[index].theta = Number(msg.theta);\r\n            network.players[index].loc = Number(msg.theta / (2 * Math.PI));\r\n        }\r\n    });\r\n    rs.on(\"update_my_theta\", function(msg) {\r\n        if (msg.theta !== null) {\r\n\r\n            var index = get_index_by_id(id);\r\n\r\n            network.players[index].theta = Number(msg.theta);\r\n            network.players[index].loc = Number(msg.theta / (2 * Math.PI));\r\n            \r\n        }\r\n    });\r\n    rs.recv(\"update_circle_x\", function(uid, msg) {\r\n        if (msg.x_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n\r\n            var index = get_index_by_id(msg.id);\r\n\r\n            player_xy[index].x_pos = msg.x_pos;\r\n            $(\"#\" + index).attr(\"cx\", msg.x_pos);\r\n            \r\n        }\r\n    });\r\n    rs.on(\"update_my_circle_x\", function(msg) {\r\n        if (msg.x_pos !== null) {\r\n            var index = get_index_by_id(id);\r\n\r\n            network.players[index].loc = Number(msg.new_loc);\r\n            player_xy[index].x_pos = msg.x_pos;\r\n            $(\"#\" + index).attr(\"cx\", msg.x_pos);\r\n            \r\n        }\r\n    });\r\n    rs.recv(\"update_circle_y\", function(uid, msg) {\r\n        if (msg.y_pos !== null) {\r\n            var index = get_index_by_id(msg.id);\r\n            player_xy[index].y_pos = msg.y_pos;\r\n            $(\"#\" + index).attr(\"cy\", msg.y_pos);\r\n            \r\n        }\r\n    });\r\n    rs.recv(\"update_my_circle_y\", function(msg) {\r\n        if (msg.y_pos !== null) {\r\n            var index = get_index_by_id(id);\r\n            player_xy[index].y_pos = msg.y_pos;\r\n            $(\"#\" + index).attr(\"cy\", msg.y_pos);\r\n            \r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_circle\", function(uid, msg) {\r\n        if (msg !== null) {\r\n\r\n            var index = get_index_by_id(msg.id);\r\n\r\n\r\n            player_xy[index].x_pos = msg.x_pos;\r\n            player_xy[index].y_pos = msg.y_pos;\r\n\r\n            $(\"#\" + msg.id).attr(\"cy\", msg.y_pos);\r\n            $(\"#\" + msg.id).attr(\"cx\", msg.x_pos);\r\n            \r\n        }\r\n    });\r\n\r\n    rs.on(\"update_my_circle\", function(msg) {\r\n        if (msg !== null) {\r\n\r\n            var index = get_index_by_id(msg.id);\r\n\r\n\r\n            player_xy[index].x_pos = msg.x_pos;\r\n            player_xy[index].y_pos = msg.y_pos;\r\n\r\n            $(\"#\" + msg.id).attr(\"cy\", msg.y_pos);\r\n            $(\"#\" + msg.id).attr(\"cx\", msg.x_pos);\r\n            \r\n\r\n        }\r\n    });\r\n\r\n    /* \r\n        This is the new handler for updating \r\n        the state of an experiment after receiving\r\n        a new message determining that a new player has made a move\r\n        the message object looks like this:\r\n                var obj = {\r\n                    id: id,\r\n                    new_loc: new_loc,\r\n                    new_pos: new_pos,\r\n                    x_pos: myX,\r\n                    y_pos: myY,\r\n                    theta: theta,\r\n                    iterx: iterx,\r\n                    itery: itery\r\n                    x_rate: x_rate,\r\n                    y_rate: y_rate\r\n                }\r\n        NOT YET IMPLEMENTED\r\n    */\r\n    rs.recv(\"update_setting\", function (uid, msg) {\r\n        if (msg !== null) {\r\n            if (x_rate === 0 && y_rate === 0) {\r\n\r\n            } else if (x_rate === 0) {\r\n\r\n            } else if (y_rate === 0) {\r\n\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n    rs.on(\"update_my_setting\", function (msg) {\r\n        if (msg !== null) {\r\n\r\n        }\r\n    });\r\n\r\n\r\n\r\n\r\n    rs.recv(\"update_subsetting\", function(uid, msg) {\r\n        //console.log(msg);\r\n        if (msg.allow_x !== null) allow_x = msg.allow_x;\r\n        if (msg.allow_y !== null) allow_y = msg.allow_y;\r\n        if (msg.curr_sub_y !== null) curr_sub_y = msg.curr_sub_y;\r\n\r\n        if (curr_sub_y == price_subrounds) {\r\n            curr_sub_y = 0;\r\n            flag = 0;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"config\", function(uid, msg) {\r\n        //assign new synchronizer\r\n        if (!chosen) keeper = in_group[Math.floor(Math.random() * in_group.length)];\r\n        chosen = true;\r\n\r\n        //set all config values\r\n        subperiods = rs.config.subperiods;\r\n        period_length = rs.config.period_length;\r\n        console.log(\"period length=\" + period_length)\r\n        t = rs.config.t;\r\n        x_rate = rs.config.percent_cpsx;\r\n        y_rate = rs.config.percent_cpsy;\r\n\r\n        if (rs.config.payoff_func === 0) {\r\n            transport_cost = linear_cost;\r\n        } else {\r\n            transport_cost = quadratic_cost;\r\n            quadratic = true;\r\n            linear = false;\r\n        }\r\n\r\n        paid_round = rs.config.paid;\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n        debug1 = rs.config.payoff_debug;\r\n        debug2 = rs.config.payoff_debug2;\r\n        debug3 = rs.config.payoff_debug3;\r\n\r\n        flow_opts = rs.config.p2_options;\r\n\r\n        scalar_x = rs.config.scale_x;\r\n        scalar_y = rs.config.scale_y;\r\n\r\n        price_subrounds = rs.config.num_sp_settingy;\r\n\r\n        payoff_mirror = rs.config.payoff_mirror;\r\n\r\n        rs.send(\"setup\", {\r\n            chosen: chosen,\r\n            keeper: keeper\r\n        });\r\n    });\r\n\r\n    rs.recv(\"setup\", function(uid, msg) {\r\n        if (msg.chosen !== null) chosen = msg.chosen;\r\n        if (msg.keeper !== null) keeper = msg.keeper;\r\n\r\n        if (id == keeper) {\r\n            var tmp = network.players;\r\n            rs.send(\"sync_net\", {\r\n                tmp: tmp\r\n            });\r\n            \r\n        }\r\n\r\n        col = '#0066FF'; //we always want to be blue\r\n\r\n        document.getElementById(\"color\").style.color = col;\r\n        document.getElementById(\"period\").innerHTML = \"Period: \" + rs.period;\r\n\r\n        var tmp_id = \"\";\r\n        for (var i = 0; i < id.length - 15; ++i) {\r\n            tmp_id += id[i];\r\n        }\r\n        document.getElementById(\"subj\").innerHTML = \"Subject: \" + rs.user_id;\r\n\r\n        //remove progress bar for continuous game types\r\n        //if(game_type == \"continuous\") document.getElementById(\"prog\").style.visibility=\"hidden\";\r\n        //if(rs.config.show_secs_left === 0) document.getElementById(\"time\").style.visibility=\"hidden\";\r\n\r\n        if (paid_round) document.getElementById(\"paid\").innerHTML = \"Scoring Period\";\r\n        else document.getElementById(\"paid\").innerHTML = \"Unpaid Practice Period\";\r\n\r\n        options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: false\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: true,\r\n                clickable: true\r\n            },\r\n            yaxis: {\r\n                show: false,\r\n                reserveSpace: null,\r\n                min: 0,\r\n                max: 1,\r\n                position: \"left\",\r\n                ticks: 1,\r\n                tickDecimals: 2,\r\n                tickColor: '#858585'\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 1,\r\n                ticks: 1,\r\n                tickDecimals: 3,\r\n                tickColor: '#858585',\r\n                tickFormatter: function(val, axis) {\r\n                    return val.toFixed(axis.tickDecimals);\r\n                }\r\n            }\r\n        };\r\n\r\n        p2_options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: true\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: false,\r\n                clickable: false\r\n            },\r\n            yaxis: {\r\n                min: 0,\r\n                ticks: 2,\r\n                tickColor: '#858585',\r\n                position: \"right\"\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 30,\r\n                tickColor: '#858585',\r\n                ticks: 0\r\n            }\r\n        };\r\n\r\n        $(\"#myModal\").modal('hide');\r\n        waiting = 0;\r\n    });\r\n\r\n    rs.recv(\"sync_net\", function(uid, msg) {\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            network.players[i] = msg.tmp[i];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"sync_time\", function(uid, msg) {\r\n        if (msg.time !== null) {\r\n            time = msg.time;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"get_silo\", function(uid, msg) {\r\n        id = r.username;\r\n        if (msg.curr_silo !== null && id == msg.id && msg.id !== null) {\r\n            silo_num = msg.curr_silo;\r\n        }\r\n    });\r\n\r\n}]);"}, "model": "expecon.page", "pk": 125}, {"fields": {"experiment": 18, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t\t<title>Finish</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<table class=\"table table-bordered table-condensed\">\r\n\t\t\t\t<thead>\r\n\t\t\t\t\t<tr><th>Period</th><th>Points</th><th>Earnings</th></tr>\r\n\t\t\t\t</thead>\r\n\t\t\t\t<tbody id=\"results\">\r\n\t\t\t\t\t<tr ng-repeat=\"points in pointsByPeriod track by $index\">\r\n\t\t\t\t\t\t<td>{{ $index + 1 }}</td><td>{{ points | number:2 }}</td><td>${{ points | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"warning\">\r\n\t\t\t\t\t\t<td>Average:</td><td>{{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td><td>${{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"success\">\r\n\t\t\t\t\t\t<td>Total:</td><td>{{ $root.totalPoints | number:2 }}</td><td>${{ $root.totalPoints | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Finish", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", function($rootScope, $scope, rs) {\r\n\trs.on_load(function() {\r\n\t\t$scope.pointsByPeriod = rs.subject[rs.user_id].points_by_period();\r\n\t\t$scope.pointsByPeriod.shift();\r\n\t});\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 126}]