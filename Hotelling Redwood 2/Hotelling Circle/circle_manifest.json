[{"fields": {"name": "Hotelling Port", "admin_css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "comments": "Port of Hotelling to Redwood2\r\n\r\nwork in progress.", "experimenter": 1, "admin_html": "<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n  <head>\r\n\t\t<title>Hotelling Admin</title>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodAdmin.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n\t<body ng-controller=\"AdminCtrl\">\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar-inner\">\r\n\t\t\t\t<div class=\"container-fluid\">\r\n\t\t\t\t\t<div class=\"brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t\t<div class=\"nav-collapse collapse\">\r\n\t\t\t\t\t\t<p class=\"navbar-text pull-right\">Administrator</p>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"span3\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"span3\">\r\n\t\t\t\t\t\t\t<div class=\"well sidebar-nav\">\r\n\t\t\t\t\t\t\t\t<ul class=\"nav nav-list\">\r\n\t\t\t\t\t\t\t\t\t<li><span id=\"router-status\" class=\"badge badge-important\"></span></li>\r\n\t\t\t\t\t\t\t\t</ul>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"span3\">\r\n\t\t\t\t\t\t\t<div class=\"well sidebar-nav\">\r\n\t\t\t\t\t\t\t\t<ul class=\"nav nav-list\">\r\n\t\t\t\t\t\t\t\t\t<li><a href=\"admin/payouts\" target=\"_blank\">View Payouts</a></li>\r\n\t\t\t\t\t\t\t\t\t<li><a id=\"archive\" href=\"#\">Archive Session</a></li>\r\n\t\t\t\t\t\t\t\t\t<li><a id=\"download\" href=\"admin/download\">Download Data</a></li>\r\n\t\t\t\t\t\t\t\t</ul>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"span9\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"span9\">\r\n\t\t\t\t\t\t\t<p>Subjects:</p>\r\n\t\t\t\t\t\t\t<table class=\"table table-bordered table-condensed table-striped\">\r\n\t\t\t\t\t\t\t\t<thead>\r\n\t\t\t\t\t\t\t\t<tr><th>ID</th><th>Group</th><th>Period</th><th style=\"width: 150px;\"></th></tr>\r\n\t\t\t\t\t\t\t\t</thead>\r\n\t\t\t\t\t\t\t\t<tbody id=\"subject-list\">\r\n\t\t\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t\t\t</table>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"span6\">\r\n\t\t\t\t\t\t\t<button id=\"start-session\" class=\"btn btn-success\">Start Session</button>\r\n\t\t\t\t\t\t\t<button id=\"refresh-subjects\" class=\"btn btn-info\" title=\"Attempt recover by refreshing all subject browsers\">Recover Session</button>\r\n\t\t\t\t\t\t\t<button id=\"reset-session\" class=\"btn btn-danger\">Reset Session</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div class=\"span3\">\r\n\t\t\t\t\t\t\t<div class=\"pull-right\">\r\n\t\t\t\t\t\t\t\t<button id=\"pause-session\" class=\"btn btn-warning\" disabled=\"disabled\">Pause</button>\r\n\t\t\t\t\t\t\t\t<button id=\"resume-session\" class=\"btn btn-primary\" disabled=\"disabled\">Resume</button>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n      <div class='row'>\r\n        <div class=\"well\" style=\"width:900px\">\r\n          <div class='span6'>\r\n            <table>\r\n            <td style=\"padding-bottom:10px;padding-right:10px\">\r\n              <input id=\"group_size\" type=\"integer\" value=\"\" placeholder=\"Groups\" style=\"text-align: left; width:4em;\"><span id=\"group_size\">\r\n            </td>\r\n            <td>\r\n              <div class=\"btn-group\">\r\n              <button type=\"button\" class=\"btn btn-primary\" id=\"set_group_size\">Set Group Size</button>\r\n              <!-- <button type=\"button\" class=\"btn btn-danger\" id=\"set_period\">Start Period</button> -->\r\n              </div>\r\n             \r\n            </td>\r\n            <td style=\"padding-bottom:10px;padding-right:10px;padding-left:20px\">\r\n              <input id=\"silo_size\" type=\"integer\" value=\"\" placeholder=\"Silo sz\" style=\"text-align: left; width:3em;\"><span id=\"silo_size\">\r\n            </td>\r\n            <td style=\"padding-bottom:10px;\">\r\n              <button type=\"button\" class=\"btn btn-primary\" id=\"set_silo_size\">Set Silo Sizes</button>\r\n              \r\n            </td>\r\n            </table>\r\n          </div>\r\n          <div class='span3'>\r\n              <div id=\"current_group\"></div>\r\n            </div>\r\n            <div class='span3'>\r\n              <div id='current_silo'></div>\r\n            </div>\r\n          <hr>\r\n          <div class='row'>\r\n            \r\n          </div>\r\n        </div>\r\n      </div>\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"span12\">\r\n\t\t\t\t\t<hr/>\r\n\t\t\t\t\t<p>Configuration:</p>\r\n\t\t\t\t\t<load-config></load-config>\r\n\t\t\t\t\t<div style=\"overflow: auto;\">\r\n\t\t\t\t\t\t<table class=\"config table table-bordered table-striped table-condensed\"></table>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n</html>\r\n", "admin_js": "  Redwood.controller(\"AdminCtrl\", [\"$rootScope\", \"$scope\", \"Admin\", function($rootScope, $scope, ra) {\r\n    \r\n    var new_period = 2;\r\n    var group_size = 2;\r\n    var silo_size = 1;\r\n    var silos = [[],[],[],[],[],[],[],[],[],[],[],[]];\r\n    var subjs = [];\r\n    $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n    $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n  \r\n    var Display = { //Display controller\r\n  \r\n      initialize: function() {\r\n     \r\n        $(\"#start-session\").click(function () {\r\n          $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n          ra.trigger(\"start_session\");\r\n        });\r\n  \r\n        ra.on(\"start_session\", function() {\r\n          $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n          $(\"#pause-session\").removeAttr(\"disabled\");\r\n        });\r\n  \r\n        $(\"#refresh-subjects\").click(function () {\r\n          $(\"#refresh-subjects\").attr(\"disabled\", \"disabled\");\r\n          ra.refreshSubjects().then(function() {\r\n            $(\"#refresh-subjects\").removeAttr(\"disabled\");\r\n          });\r\n        });\r\n  \r\n        $(\"#reset-session\").click(function () {\r\n          ra.reset();\r\n        });\r\n  \r\n        $(\"#pause-session\").click(function () {\r\n          $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n          ra.trigger(\"pause\");\r\n        });\r\n        ra.on(\"pause\", function() {\r\n          $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n        });\r\n  \r\n        $(\"#resume-session\").click(function () {\r\n          $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n          ra.trigger(\"resume\");\r\n        });\r\n        ra.on(\"resume\", function() {\r\n          $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n          $(\"#pause-session\").removeAttr(\"disabled\");\r\n        });\r\n  \r\n        ra.on_subject_paused(function(userId) {\r\n          $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n          $(\"tr.subject-\" + userId).addClass(\"warning\"); //Display current period for each user\r\n          $(\"tr.subject-\" + userId + \" :nth-child(4)\").text(\"Paused\"); //Display current period for each user\r\n        });\r\n  \r\n        ra.on_all_paused(function() {\r\n          $(\"#resume-session\").removeAttr(\"disabled\");\r\n        });\r\n  \r\n        ra.on_subject_resumed(function(user) {\r\n          $(\"tr.subject-\" + user).removeClass(\"warning\"); //Display current period for each user\r\n          $(\"tr.subject-\" + user + \" :nth-child(4)\").text(\"\"); //Display current period for each user\r\n        });\r\n  \r\n        $(\"#archive\").click(function () {\r\n          var r = confirm(\"Are you sure you want to archive this session?\");\r\n          if(r == true) {\r\n            ra.delete_session();\r\n          }\r\n        });\r\n  \r\n        ra.on_router_connected(function(connected) { //Display router connection status\r\n          var status = $(\"#router-status\");\r\n          if (connected) {\r\n            status.text(\"Router Connected\");\r\n            status.removeClass(\"badge-important\");\r\n            status.addClass(\"badge-success\");\r\n          } else {\r\n            status.text(\"Router Disconnected\");\r\n            status.removeClass(\"badge-success\");\r\n            status.addClass(\"badge-important\");\r\n          }\r\n        });\r\n  \r\n        ra.on_set_period(function(user, period) {\r\n          $(\"tr.subject-\" + user + \" :nth-child(3)\").text(period); //Display current period for each user\r\n        });\r\n  \r\n        ra.on_set_group(function(user, group) {\r\n          $(\"tr.subject-\" + user + \" :nth-child(2)\").text(group); //Display group for each user\r\n        });\r\n  \r\n        ra.on_register(function(user) { //Add a row to the table to each user\r\n          $(\"#subject-list\").empty();\r\n          for(var i = 0, l = ra.subjects.length; i < l; i++) {\r\n            $(\"#subject-list\").append($(\"<tr>\").addClass(\"subject-\" + ra.subjects[i].user_id).append(\r\n              $(\"<td>\").text(ra.subjects[i].user_id).after(\r\n                $(\"<td>\").text(0).after(\r\n                  $(\"<td>\").text(0).after(\r\n                    $(\"<td>\").text(\"\"))))));\r\n          }\r\n        });\r\n  \r\n      \r\n  \r\n\t\t\t$(\"#set_period\").click(function() {\r\n\t\t\t  \tif(new_period !== 0 && new_period !== undefined && new_period !== null && ra.subjects.length > 0){\r\n\t\t\t\t    //do_lottery();\r\n\t\t\t\t   \tfor(var i = 0, l = ra.subjects.length; i < l; i++) {\r\n\t\t              ra.set_period(new_period, ra.subjects[i].user_id);\r\n\t\t            }\r\n\t\t\t\t    ++new_period;\r\n\t\t\t   }\r\n\t\t\t   $(\"#set_period\").html(\"Start Period: \" + new_period);\r\n\t  \t});\r\n        \r\n        $(\"#set_group_size\").click(function() {\r\n          group_size = Number(document.getElementById('group_size').value);\r\n          \r\n          if(group_size > 0 && group_size !== undefined && group_size !== null && !isNaN(group_size)){\r\n            ra.trigger(\"do_lottery\");\r\n          }\r\n          $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n          \r\n        });\r\n  \r\n\tra.on(\"do_lottery\" , function () {\r\n\t\tsetGroups = true;\r\n\t    var i = 0;\r\n\t    var tmp = [];\r\n\t    \r\n\t    for(var i = 0, l = ra.subjects.length; i < l; i++) {\r\n\t      var subj = {};\r\n\t      subj.userid = ra.subjects[i].user_id;\r\n\t      subj.a = 0;\r\n\t      tmp.push(subj);\r\n\t    }\r\n\r\n\t    \r\n\t    var curr_group = 1;\r\n\t    var count = 0;\r\n\t    while(count != tmp.length){\r\n\t      var rand = Math.floor(Math.random() * (tmp.length));\r\n\t      if(tmp[rand].a === 0){\r\n\t        tmp[rand].a = 1;\r\n\t        \r\n\t        ra.set_group(curr_group, tmp[rand].userid);\r\n\t        count++;\r\n\t        if((count % group_size === 0) && count !== 0) curr_group++;\r\n\t      }\r\n\t    }\r\n\t});\r\n  \r\n\r\n  \r\n        $(\"#set_silo_size\").click(function() {\r\n          tmp = Number(document.getElementById('silo_size').value);\r\n          if(tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length){\r\n            silo_size = Number(document.getElementById('silo_size').value);\r\n            ra.trigger(\"set_silo\");\r\n          } else {\r\n            alert('Please make sure the silo size is less than or equal to the number of subjects');\r\n          }\r\n          $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n        });\r\n  \r\n        ra.on(\"set_silo\", function() {\r\n  \r\n          tmp = Number(document.getElementById('silo_size').value);\r\n          \r\n          if(tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length){\r\n            silo_size = Number(document.getElementById('silo_size').value);\r\n            subjs = [];\r\n            silos = [[],[],[],[],[],[],[],[],[],[],[],[]];\r\n            \r\n            for(var i in ra.subjects){\r\n              var subj = {};\r\n              subj.id = ra.subjects[i];\r\n              subj.a = 0;\r\n              subj.silo = -1;\r\n              subjs.push(subj);    \r\n            }\r\n            \r\n            var count = 0;\r\n            var curr_silo = 0;\r\n  \r\n            while(count != subjs.length){\r\n              var rand = Math.floor(Math.random() * (subjs.length));\r\n              if(subjs[rand].silo == -1){\r\n                subjs[rand].silo = curr_silo;\r\n  \r\n                count++;\r\n                silos[curr_silo].push(subjs[rand]);\r\n                \r\n                if(silo_size == 1) curr_silo++;\r\n                else if((count % silo_size === 0) && count !== 0) curr_silo++;\r\n              }\r\n            }\r\n            console.log('success setting silos. silo_size = ' + silo_size); \r\n          }\r\n    \r\n  \r\n        });\r\n  \r\n        ra.on_set_config(function(config) { //Display the config file\r\n          $(\"table.config\").empty();\r\n          var a = $.csv.toArrays(config);\r\n          for (var i = 0; i < a.length; i++) {\r\n            var row = a[i];\r\n            var tr = $(\"<tr>\");\r\n            for (var j = 0; j < row.length; j++) {\r\n              var cell = row[j];\r\n              var td = $((i == 0 ? \"<th>\" : \"<td>\")).text(cell);\r\n              tr.append(td);\r\n            }\r\n            $(\"table.config\").append(tr);\r\n          }\r\n        });\r\n  \r\n  \r\n  \r\n      }\r\n    };\r\n  \r\n    var resetGroups = function() {\r\n      var config = ra.get_config(1, 0) || {};\r\n      for (var i = 0; i < ra.subjects.length; i++) { //set all subjects to group 1 (this is so that matching can be changed per period)\r\n        if($.isArray(config.groups)) {\r\n          for(var groupId = 0; groupId < config.groups.length; groupId++) {\r\n            if($.isArray(config.groups[groupId])) {\r\n              if(config.groups[groupId].indexOf(parseInt(ra.subjects[i].user_id)) > -1) { //Nested group array\r\n                ra.set_group(groupId + 1, ra.subjects[i].user_id);\r\n              }\r\n            } else {\r\n              ra.set_group(1, ra.subjects[i].user_id);\r\n            }\r\n          }\r\n        } else {\r\n          ra.set_group(1, ra.subjects[i].user_id);\r\n        }\r\n      }\r\n    };\r\n  \r\n  \r\n  \r\n    Display.initialize();\r\n  \r\n    ra.on_load(function () {\r\n      resetGroups(); //Assign groups to users\r\n    });\r\n  \r\n    ra.on_register(function(user) { //Add a row to the table to each user\r\n      resetGroups();\r\n    });\r\n  \r\n    ra.on(\"start_session\", function() {\r\n      ra.start_session();\r\n    });\r\n  \r\n    ra.on(\"pause\", function() {\r\n      ra.pause();\r\n    });\r\n  \r\n    ra.on(\"resume\", function() {\r\n      ra.resume();\r\n    });\r\n  \r\n    \r\n      \r\n  \r\n  }]);\r\n  \r\n", "rt_js": ""}, "model": "expecon.experiment", "pk": 8}, {"fields": {"experiment": 8, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t\t<title>Wait</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-lg-12\">\r\n\t\t\t\t\tPlease wait for experiment to start...\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Wait", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", function($rootScope, $scope, rs) {\r\n\trs.on_load(function() {\r\n\t\trs.next_period();\r\n\t});\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 43}, {"fields": {"experiment": 8, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n  <head>\r\n\t\t<title>Start</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n    <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/synchronizedStopWatch.js\"></script>\t\t\r\n    \r\n    <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.js\"></script>\r\n    <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.selection.js\"></script>\r\n    \r\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body style=\"padding-top:60px\" ng-controller=\"SubjectCtrl\">\r\n  <div class='container'>\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n        <div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n            <div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n            <ul class=\"nav navbar-nav\">\r\n                <li class=\"active\">\r\n                    <a id=\"subj\">User ID: <span>{{$root.user_id}}</span></a>\r\n                </li>\r\n            </ul>\r\n            <div class=\"navbar-right\">\r\n                <div id=\"period\" class=\"navbar-text\">Period: <span>{{$root.period}}</span></div>\r\n                <div id=\"paid\" class=\"navbar-text\">Paid: </div>\r\n                <div id=\"curr_score\" class=\"navbar-text\">Score:</div>\r\n                <div id=\"time\" class=\"navbar-text\">Time:</div>\r\n                \r\n            </div>\r\n        </div>\r\n    </div>\r\n    \r\n    <!-- Modal -->\r\n    <div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n    \r\n      <div class=\"modal-dialog\">\r\n        <div class=\"modal-content\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n  \r\n  \r\n\r\n\r\n    <div class='row'>\r\n      <div class='col-md-9'>\r\n        <div class=\"progress\" id=\"progress\">\r\n          <div id='progBar' class=\"progress-bar progress-bar-striped active\"  role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"130\" style=\"width: 0%\">\r\n            \r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div class='col-md-3'>\r\n        <h4 id = \"total_score\" style=\"visibility:hidden\">Total Score: </h4>\r\n      </div>\r\n    </div>\r\n\r\n    <div class='row'>\r\n      <h3 id=\"color\">Your color</h3>\r\n      <p id=\"x_ref\"></p>\r\n      <p id=\"y_ref\"></p> \r\n      <p id=\"x_loc\"></p>\r\n      <p id=\"test\"></p>\r\n      <h2 id=\"select\" style=\"color:red\"></h2>\r\n    </div>\r\n    <div class='row'>\r\n      <table>\r\n        <tr>\r\n        <td><div class=\"demo-container\" >\r\n           <div id=\"placeholder\" style=\"height:450px; width:450px\" class=\"demo-placeholder\">  </div>\r\n        </div></td>\r\n        <td style=\"padding-left: 20px\"><div class=\"demo-container\" >\r\n           <div id=\"placeholder2\" style=\"height:450px; width:450px\" class=\"demo-placeholder\">  </div>\r\n        </div></td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n  \r\n  </div>\r\n</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Start", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", 'SynchronizedStopWatch', function($rootScope, $scope, rs, SynchronizedStopWatch) {\r\n    var id = 0; //player id\r\n    var current_period = 0;\r\n    var curr_subperiods = 1;\r\n    var num_of_players = 0; //number of players in our group\r\n    var price = 0;\r\n    var network = {}; //player object\r\n    var options; //plot 1 options\r\n    var p2_options; //plot 2 options\r\n    var player_pos = []; //location of opponent's positions\r\n    var target_pos = [0, 0]; //our current target location for continuous time\r\n    var plot;\r\n    var x_rate = 1; //percent change per second along x axis\r\n    var y_rate = 1; //percent change per second along y axis\r\n    var keeper; //game synchronizer from our group\r\n    var chosen = false; //flag\r\n    var new_loc = 0;\r\n    var new_pos = 0;\r\n    var transport_cost;\r\n    var time = 0;\r\n    var tend;\r\n    var subperiods = 0;\r\n    var paid_round = false;\r\n    var period_length = 0;\r\n    var t; //config field\r\n    var r; //redwood\r\n    var intersects = []; //array of intersect locations on x axis\r\n    var colors = ['#FF6699', '#339966', '#0066CC', '#CCA300'];\r\n    var mouse = []; //for drawing crosshairs on plot\r\n    var cummulative_payoff = 0;\r\n    var flow_payoff = []; //should be a better way of storing flow payoffs for scalability reasons..\r\n    var flow_payoff2 = [];\r\n    var game_type = \"continuous\";\r\n    var debug = false; //player 'Vs'\r\n    var debug2 = false; //intersect lines\r\n    var debug3 = false; //market share box shading\r\n    var col; //player's blue color. may be unnecessary to store this info now\r\n    var p2_t = 0; //fake time interval for plotting flow payoffs. should be changed\r\n    var flow_opts; //flow payoff debug options\r\n    var last_20 = [];\r\n    //var l = 0;\r\n    var my_pos; //player's current location and price \r\n    var sub_pay = [\r\n        [],\r\n        []\r\n    ]; //stores each player's payoffs at end of round for discrete games\r\n    var scalar_x = Number(1);\r\n    var scalar_y = Number(1);\r\n    var allow_x = 1; //discrete choosing settings\r\n    var allow_y = 0;\r\n    var price_subrounds = 1; //how many price rounds after a location round we have\r\n    var curr_sub_y = 0;\r\n    var curr_i = 0;\r\n    var p2_ticks = [];\r\n    var flag = 0; //for restarting position after new subgames\r\n    var waiting = 1; //to disable user interface\r\n    var in_group = []; //who is in my redwood group\r\n    var group_num = 0;\r\n    var silo_num = 0;\r\n    var r_debug = 0;\r\n\r\n    var total_flow = [];\r\n    var total_flow2 = [];\r\n\r\n    var filler = [0, 0]; //for making bar graphs\r\n\r\n    var quadratic = false;\r\n    var linear = true;\r\n\r\n    var payoff_mirror = 0;\r\n    /*\r\n     * returns color associated with a player\r\n     */\r\n    function player_color(key) {\r\n        for (var i = 0; i < network.players.length; ++i)\r\n            if (network.players[i].id == key) return network.players[i].color;\r\n\r\n        return '#000000';\r\n    }\r\n\r\n    /*\r\n     * returns all player's positions as x,y points\r\n     */\r\n    function get_opp_pos() {\r\n        var res = [];\r\n        for (var i = 0; i < player_pos.length; ++i) {\r\n            res.push([\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns points to draw a line on given axis to indicate where players can choose\r\n     */\r\n    function gen_targ_line(axis) {\r\n        var res = [];\r\n        if (axis == \"x\") {\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc) - 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc), 1]);\r\n        } else if (axis == \"y\") {\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0, Number(new_pos) - 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([1, Number(new_pos)]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns market boundary points for a given player to draw 'payoff area' box\r\n     */\r\n    function get_market_bounds(key) {\r\n        var res = [];\r\n        for (var i in network.players) {\r\n            if (network.players[i].id == key) {\r\n                res.push(network.players[i].bound_lo);\r\n                res.push(network.players[i].bound_hi);\r\n                res.push(network.players[i].price);\r\n            }\r\n        }\r\n\r\n        var out = [];\r\n        out.push([res[0], null]);\r\n\r\n        out.push([res[0], 0]);\r\n        out.push([res[0], res[2]]);\r\n\r\n\r\n        out.push([res[1], res[2]]);\r\n        out.push([res[1], 0]);\r\n        out.push([res[1], null]);\r\n\r\n        return out;\r\n    }\r\n\r\n    var tmp_a0 = [];\r\n    var tmp_a1 = [];\r\n\r\n    //Used to hold the reflections. This is needed because Flot will try to connect\r\n    //points even if there's a break in the function, so we split up the positive\r\n    //reflections and the negative ones for both players.\r\n    var tmp_a0_front = [];\r\n    var tmp_a0_back = [];\r\n    var tmp_a1_front = [];\r\n    var tmp_a1_back = [];\r\n\r\n    var market_b = [];\r\n\r\n    /*\r\n     * redraws and updates data for plot 1\r\n     */\r\n    function update_plot() {\r\n        if (waiting) return;\r\n\r\n        sort_players();\r\n        var tmp = [target_pos];\r\n        var i = get_index_by_id(id);\r\n\r\n        get_players();\r\n\r\n        var tmp_col = '#C7C7C7';\r\n\r\n        if (game_type == \"continuous\") {\r\n            targ_line = [];\r\n            my_pos = [\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ];\r\n        } else if (game_type != \"continuous\") {\r\n            var axis = \"\";\r\n            if (allow_x && !allow_y) axis = \"x\";\r\n            else if (!allow_x && allow_y) axis = \"y\";\r\n\r\n            tmp_col = '#B20000';\r\n            targ_line = gen_targ_line(axis); //draw axis choosing line if in discrete time\r\n        }\r\n\r\n        tmp_a0 = [];\r\n        tmp_a1 = [];\r\n\r\n        //Used to hold the reflections. This is needed because Flot will try to connect\r\n        //points even if there's a break in the function, so we split up the positive\r\n        //reflections and the negative ones for both players.\r\n        tmp_a0_front = [];\r\n        tmp_a0_back = [];\r\n        tmp_a1_front = [];\r\n        tmp_a1_back = [];\r\n\r\n        market_b = [];\r\n        intersects = [0, mouse[0], 1];\r\n\r\n        var opp_pos = get_opp_pos();\r\n\r\n        //This isn't done for n players -- only players 0 & 1\r\n\r\n        if (debug1) { // display payoff debug options, player \"V's\"\r\n            //if we're doing linear, use linear v generator, otherwise do quad\r\n            if (linear) {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = a_mirror(0);\r\n                    tmp_a1 = a_mirror(1);\r\n                } else {\r\n                    tmp_a0 = a(0);\r\n                    tmp_a1 = a(1);\r\n                }\r\n            } else {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = quad_mirror(0);\r\n                    tmp_a1 = quad_mirror(1);\r\n                } else {\r\n                    tmp_a0 = quad(0);\r\n                    tmp_a1 = quad(1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (debug2) { //market intersection lines\r\n            intersects = find_intersect_pts();\r\n            intersects[num_of_players + 1] = mouse[0];\r\n            options.xaxis.ticks = intersects;\r\n        }\r\n\r\n        if (debug3) { //payoff area shading\r\n            market_b = get_market_bounds(id);\r\n            //console.log(market_b);\r\n        }\r\n\r\n        options.xaxis.ticks = intersects;\r\n\r\n        plot = $.plot(\"#placeholder\", [\r\n\r\n            {\r\n                data: opp_pos[0],\r\n                /*hoverable: false,*/ color: player_pos[0][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[0][2]\r\n                }\r\n            }, {\r\n                data: opp_pos[1],\r\n                color: player_pos[1][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[1][2]\r\n                }\r\n            }, {\r\n                data: targ_line,\r\n                color: '#000000',\r\n                lines: {\r\n                    show: true,\r\n                    fill: false\r\n                }\r\n            }, {\r\n                data: tmp,\r\n                color: tmp_col,\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: tmp_col\r\n                }\r\n            },\r\n\r\n            {\r\n                data: tmp_a0,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            },\r\n\r\n\r\n            {\r\n                data: tmp_a1,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            },\r\n\r\n\r\n            {\r\n                data: my_pos,\r\n                color: '#000000',\r\n                points: {\r\n                    show: true,\r\n                    radius: 5,\r\n                    fill: true,\r\n                    fillColor: '#0099FF'\r\n                }\r\n            }, {\r\n                data: market_b,\r\n                color: col,\r\n                lines: {\r\n                    show: true,\r\n                    fill: 0.25\r\n                }\r\n            }\r\n\r\n        ], options);\r\n    }\r\n\r\n    var date = 0;\r\n    var old_date = 0;\r\n\r\n    /*\r\n     * rewdraw and update flow payoff plot\r\n     */\r\n    function update_plot2() {\r\n            if (waiting) return;\r\n\r\n            if (game_type == \"continuous\") {\r\n                //make sure everyone is sorted\r\n                sort_players();\r\n                find_intersect_pts();\r\n\r\n                //so we can get the correct payoffs\r\n                var index = get_index_by_id(id);\r\n                var pay = payoff(index);\r\n                rs.send(\"update_payoff\", {\r\n                    pay: pay,\r\n                    index: index\r\n                });\r\n\r\n                //let's find how long it was since we updated our payoffs      \r\n                date = new Date();\r\n                date.getTime();\r\n\r\n                var d = date - old_date;\r\n                old_date = date;\r\n\r\n                p2_t += 0.12;\r\n                //p2_t += d;\r\n\r\n                cummulative_payoff += network.players[get_index_by_id(id)].payoff * (d / (period_length * 1000));\r\n\r\n                document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n                if (flow_opts == \"all\") {\r\n                    //push all player's data to be plotted\r\n                    flow_payoff.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                    flow_payoff2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                    total_flow.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                    total_flow2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                    //add extra white space to front of plot to hide end time\r\n                    p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                    last_20.push(network.players[get_index_by_id(in_group[0])].payoff);\r\n                    last_20.push(network.players[get_index_by_id(in_group[1])].payoff);\r\n\r\n                    //get rid of data more than 20seconds old\r\n                    if (time >= 20) {\r\n                        flow_payoff.shift();\r\n                        flow_payoff2.shift();\r\n                        last_20.shift();\r\n                        p2_options.xaxis.min = flow_payoff[0][0];\r\n                    }\r\n\r\n                    //scale flow payoff y axis to fit m ax payoff during the last 20 seconds \r\n                    p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(network.players[get_index_by_id(in_group[0])].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }, {\r\n                        data: flow_payoff2,\r\n                        color: player_color(network.players[get_index_by_id(in_group[1])].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }], p2_options);\r\n\r\n                } else if (flow_opts == \"own\") {\r\n                    //in this case we only plot our own payoff data\r\n                    flow_payoff.push([p2_t, network.players[get_index_by_id(id)].payoff]);\r\n                    total_flow.push([p2_t, network.players[0].payoff]);\r\n\r\n                    last_20.push(network.players[get_index_by_id(id)].payoff);\r\n                    p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                    if (time >= 20) {\r\n                        flow_payoff.shift();\r\n                        last_20.shift();\r\n                        p2_options.xaxis.min = flow_payoff[0][0];\r\n                    }\r\n\r\n                    p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }], p2_options);\r\n\r\n                } else if (flow_opts == \"none\") {\r\n                    //otherwise we plot nothing\r\n                    return;\r\n                }\r\n\r\n            } else {\r\n                //else we are in discrete time\r\n                p2_options.xaxis.tickDecimals = 0;\r\n                p2_options.xaxis.min = 0;\r\n                p2_options.xaxis.max = curr_subperiods + 2;\r\n                p2_options.xaxis.ticks = p2_ticks;\r\n\r\n                if (flow_opts == \"all\") {\r\n                    flow_payoff = plot_data(sub_pay[0], 0, 1);\r\n                    flow_payoff2 = plot_data(sub_pay[1], 0, 1);\r\n\r\n                    //set player's payoff bar graphs to have 25% opacity\r\n                    if (network.players[0].id == id) filler = [0.25, 0];\r\n                    else if (network.players[1].id == id) filler = [0, 0.25];\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(network.players[0].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: filler[0]\r\n                        }\r\n                    }, {\r\n                        data: flow_payoff2,\r\n                        color: player_color(network.players[1].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: filler[1]\r\n                        }\r\n                    }], p2_options);\r\n\r\n                } else if (flow_opts == \"own\") {\r\n\r\n                    flow_payoff = plot_data(sub_pay[get_index_by_id(id)], 0, 1);\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: 0.25\r\n                        }\r\n                    }], p2_options);\r\n                    return;\r\n                } else {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        /*\r\n         * nicely package flow payoff data for discrete time types\r\n         * div is now always 1 since lines should overlap\r\n         */\r\n    function plot_data(input, offset, div) {\r\n        var res = [];\r\n        var i = 0;\r\n        p2_ticks = [];\r\n        for (var a in input) {\r\n            if (input[a] !== 0) {\r\n                res.push([i + ((1 / div) * offset), null]);\r\n                res.push([i + ((1 / div) * offset), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), null]);\r\n                p2_ticks.push(i);\r\n                i++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * payoff debug \"V\" generating function\r\n     */\r\n    function a(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        // x-l^2+p\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n            var y = p + Math.abs(l + x);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function a_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x <= 5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x <= 5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    /*\r\n     * default\r\n     */\r\n    function linear_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(network.players[pos].loc - network.players[i].loc) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * d^2 * t\r\n     */\r\n    function quadratic_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(Math.pow(network.players[pos].loc - network.players[i].loc), 2) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * find only players that have a market share\r\n     */\r\n    function validate_players() {\r\n        var tmp = network.players;\r\n        var res = [];\r\n        //var index;\r\n        var i;\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var p1 = network.players[i];\r\n            tmp[i].valid = 1;\r\n\r\n            for (var j = 0; j < network.players.length; ++j) {\r\n                var p2 = network.players[j];\r\n\r\n                //for every player excluding yourself compare price\r\n                if (i != j) {\r\n                    if (linear) {\r\n\r\n                        if (p1.price > p2.price + t * Math.abs(p1.loc - p2.loc)) {\r\n                            tmp[i].valid = 0;\r\n\r\n                            //update player's new market bounds\r\n                            var new_lo_bound = 0;\r\n                            var new_hi_bound = 0;\r\n\r\n                            network.players[i].bound_lo = new_lo_bound;\r\n                            network.players[i].bound_hi = new_hi_bound;\r\n                        }\r\n                    } else if (quadratic) {\r\n                        var intersection = (Math.pow(p1.loc, 2) - Math.pow(p2.loc, 2) + p1.price - p2.price) / (2 * Math.abs(p1.loc - p2.loc));\r\n                        intersection = Math.abs(intersection);\r\n\r\n                        var priceScalar = p2.price + t * Math.pow(p1.loc - p2.loc, 2);\r\n\r\n                        //If the intersection occurs less than 0 or above 1, the player with the lower price `wins`\r\n                        if (!((0 < intersection) && (intersection < 1))) {\r\n\r\n                            if (p1.price > p2.price) {\r\n                                tmp[i].valid = 0;\r\n\r\n                                //update player's new market bounds\r\n                                var new_lo_bound = 0;\r\n                                var new_hi_bound = 0;\r\n\r\n                                network.players[i].bound_lo = new_lo_bound;\r\n                                network.players[i].bound_hi = new_hi_bound;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            if (tmp[i].valid == 1) res.push(network.players[i]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns array of all points along x-axis that correspond to an intersection\r\n     */\r\n    function find_intersect_pts() {\r\n        var res = [];\r\n        res.push(0);\r\n\r\n        var tmp = validate_players();\r\n        var i;\r\n\r\n        // t(lH)+(pH)+t(lL)-(pL)2t\r\n        // t(lH+lL) + (pH-pL)\r\n\r\n        //high = [i+1], low = [i]\r\n        if (linear) {\r\n\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n                var intersect1 = (t * (tmp[i + 1].loc + tmp[i].loc) + (tmp[i + 1].price - tmp[i].price)) / (2 * t);\r\n                res.push(intersect1);\r\n\r\n                if (payoff_mirror) {\r\n                    var diff = Math.abs(tmp[i].loc - tmp[i + 1].loc);\r\n                    var intersect2 = tmp[i].loc + diff;\r\n\r\n                    res.push(intersect2);\r\n                }\r\n                //console.log (res);\r\n            }\r\n\r\n\r\n\r\n        } else if (quad) {\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n\r\n                //Let's recreate the lower player on the left and right side of the boundaries\r\n                if (payoff_mirror) {\r\n                    var loc_low_one = tmp[i].loc + 1;\r\n                    var loc_low_zero = tmp[i].loc - 1;\r\n                }\r\n                var loc_low = tmp[i].loc;\r\n                var price_low = tmp[i].price;\r\n                var loc_high = tmp[i + 1].loc;\r\n                var price_high = tmp[i + 1].price\r\n\r\n                //this calculates the intersections between two quadratics\r\n                var top = (Math.pow(loc_high, 2) - Math.pow(loc_low, 2) + price_high - price_low);\r\n                var denom = (2 * Math.abs(loc_high - loc_low));\r\n                var intersection = top / denom;\r\n\r\n                //grab our inital intersection\r\n                if (intersection < 0 || intersection > 1) {\r\n                    res.push(0);\r\n                } else {\r\n                    res.push(intersection);\r\n                }\r\n                //lets grab our mirrored intersections\r\n                if (payoff_mirror) {\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored above 1\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_one, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_one));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored below 0\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_zero, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_zero));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        res.push(1);\r\n        //console.log(\"intersections between valid players at: \" + res);\r\n        var new_lo_bound;\r\n        var new_hi_bound;\r\n        var index;\r\n\r\n        /*causing issues of mis-synchronization of market boundaries by not passing over new values*/\r\n        /*now ever subject clicking recalculates the new market bounds for everyone, not just the syncronizer (keeper) - lines 456 and 467*/\r\n        //if(id == keeper){\r\n        for (i = 0; i < tmp.length; ++i) {\r\n            new_lo_bound = res[i];\r\n            new_hi_bound = res[i + 1];\r\n            index = get_index_by_id(tmp[i].id);\r\n\r\n            network.players[index].bound_lo = new_lo_bound;\r\n            network.players[index].bound_hi = new_hi_bound;\r\n\r\n            //line below did not exist before the fix..\r\n            rs.send(\"update_bounds\", {\r\n                index: index,\r\n                new_lo_bound: new_lo_bound,\r\n                new_hi_bound: new_hi_bound\r\n            });\r\n        }\r\n\r\n        //}\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * payoff = market_share * price\r\n     */\r\n    function payoff(index) {\r\n        var market_share = Math.abs(network.players[index].bound_hi - network.players[index].bound_lo) * scalar_x;\r\n\r\n        return market_share * (network.players[index].price * scalar_y);\r\n    }\r\n\r\n    /*\r\n     * sorts players in descending order. bubblesort\r\n     */\r\n    function sort_players() {\r\n        var grp = network.players;\r\n        var len = network.players.length;\r\n\r\n        for (var i = 0; i < len - 1; ++i) {\r\n            for (var j = 0; j < ((len - 1) - i); ++j) {\r\n                if (grp[j].loc > grp[j + 1].loc) {\r\n                    var tmp = grp[j + 1];\r\n                    grp[j + 1] = grp[j];\r\n                    grp[j] = tmp;\r\n                }\r\n            }\r\n        }\r\n\r\n        network.players = grp;\r\n    }\r\n\r\n    /*\r\n     * returns index in network object array of player with id 'key'\r\n     */\r\n    function get_index_by_id(key) {\r\n        var res = -1;\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (network.players[i].id == key) return i;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function get_players() {\r\n        //if(waiting) return;\r\n        if (id == keeper) {\r\n            var value = network.players;\r\n            rs.send(\"data_log\", {\r\n                value: value,\r\n                curr_subperiods: curr_subperiods,\r\n                silo_num: silo_num\r\n            });\r\n        }\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            player_pos[i] = [network.players[i].loc, network.players[i].price, network.players[i].color];\r\n        }\r\n    }\r\n\r\n    function log_data() {\r\n            if (id == keeper) {\r\n                var value = network.players;\r\n                rs.send(\"data_log\", {\r\n                    value: value,\r\n                    curr_subperiods: curr_subperiods,\r\n                    silo_num: silo_num\r\n                });\r\n            }\r\n        }\r\n    //time keeping 1s interval function\r\n    function tick() {\r\n        //console.log(\"ticking\");\r\n        if (waiting) return;\r\n\r\n        if (time <= 1) {\r\n            $(\".period\").HTML = \"Period: \" + rs.period;\r\n            network.players[get_index_by_id(id)].color = col;\r\n        }\r\n\r\n        // generate random player clicks if debug option is set\r\n        if (r_debug) {\r\n            new_loc = Math.random().toFixed(3);\r\n            new_pos = Math.random().toFixed(3);\r\n            var iterx = 0;\r\n            var itery = 0;\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n\r\n            target_pos = [Number(new_loc), Number(new_pos)];\r\n            rs.send(\"update_target\", {\r\n                new_loc: new_loc,\r\n                new_pos: new_pos,\r\n                id: id\r\n            });\r\n        }\r\n\r\n        time = time + 1;\r\n\r\n        // hope to fix any weird color overriding at start... \r\n        if (time == 5) {\r\n            for (var n in network.players) {\r\n                if (network.players[n].color == '#0066FF' && network.players[n].id != id)\r\n                    network.players[n].color = colors[1];\r\n            }\r\n        }\r\n\r\n        if (game_type == \"stage\") {\r\n            var width = ((250 / (period_length / subperiods)) * time) % 250;\r\n            $('#progBar').css('width', width + \"%\");\r\n        } else {\r\n            var width = (250 / period_length) * time;\r\n            $('#progBar').css('width', width + \"%\");\r\n        }\r\n\r\n        if (id == keeper) rs.send(\"sync_time\", {\r\n            time: time\r\n        });\r\n\r\n        //check for end of period in continous time\r\n        if (time >= period_length) {\r\n            if (id == keeper) rs.send(\"new_period\", {\r\n                current_period: current_period\r\n            });\r\n        }\r\n\r\n        if (game_type == \"simultaneous\") {\r\n            sub_pay[0][curr_subperiods - 1] = network.players[0].payoff.toFixed(2);\r\n            sub_pay[1][curr_subperiods - 1] = network.players[1].payoff.toFixed(2);\r\n\r\n            cummulative_payoff = 0;\r\n            for (i = 0; i < sub_pay[get_index_by_id(id)].length; ++i) {\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n            }\r\n\r\n            if (time % (period_length / subperiods) === 0) {\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_loc\", {\r\n                    new_loc: new_loc,\r\n                    id: id,\r\n                    iterx: iterx\r\n                });\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"new_subperiod\", {\r\n                        curr_subperiods: curr_subperiods\r\n                    });\r\n\r\n                    if (curr_subperiods == subperiods) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n            }\r\n        } else if (game_type == \"stage\") {\r\n\r\n            if (allow_x && !allow_y) document.getElementById(\"select\").innerHTML = \"Choose x\";\r\n            else if (!allow_x && allow_y) document.getElementById(\"select\").innerHTML = \"Choose y\";\r\n\r\n            if (allow_x && !flag) { //reset price at beginning of new subgame and keep old location\r\n                //new_pos = 0;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n                flag = 1;\r\n            }\r\n\r\n            if (time % (period_length / subperiods) < 1) { //at the end of every subperiod update new position on plot\r\n                console.log(\"ENDING SUBPERIOD\");\r\n                curr_i += 4;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                var offset = 1 / num_of_players;\r\n\r\n                if (allow_x) {\r\n\r\n                    rs.send(\"update_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    allow_x = 0;\r\n                    allow_y = 1; //switch to price subrounds\r\n\r\n                } else if (allow_y) {\r\n                    rs.send(\"update_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n\r\n                    ++curr_sub_y;\r\n\r\n                    if (curr_sub_y == price_subrounds) { //when we reach the last price subround, start a new subgame\r\n                        if (id == keeper) rs.send(\"set_payoffs\", {\r\n                            curr_subperiods: curr_subperiods,\r\n                            id: id\r\n                        });\r\n                        sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                        sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n\r\n                        allow_x = 1;\r\n                        allow_y = 0;\r\n\r\n                        if (id == keeper) rs.send(\"update_subsetting\", {\r\n                            allow_x: allow_x,\r\n                            allow_y: allow_y,\r\n                            curr_sub_y: curr_sub_y\r\n                        });\r\n\r\n                    }\r\n\r\n                    if (curr_sub_y == 2) {\r\n                        sub_pay[0].shift();\r\n                        sub_pay[1].shift();\r\n                    }\r\n                }\r\n\r\n                if (id == keeper) rs.send(\"new_subperiod\", {\r\n                    curr_subperiods: curr_subperiods\r\n                });\r\n\r\n                if (curr_subperiods == subperiods) { //when we go through all subperiods, it's time for a new period\r\n                    sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                    sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n                    if (id == keeper) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"update_subsetting\", {\r\n                        allow_x: allow_x,\r\n                        allow_y: allow_y,\r\n                        curr_sub_y: curr_sub_y\r\n                    });\r\n                    rs.send(\"set_payoffs\", {\r\n                        curr_subperiods: curr_subperiods,\r\n                        id: id\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        var i;\r\n\r\n        intersects = find_intersect_pts();\r\n\r\n        //document.getElementById(\"total_score\").innerHTML = \"Total Score: \" + rs.points.toFixed(3);\r\n        //document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n        //save payoff at end of round\r\n        if (sub_pay[0][curr_subperiods - 1] === undefined) {\r\n            sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n        }\r\n\r\n        if (sub_pay[1][curr_subperiods - 1] === undefined) {\r\n            sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n        }\r\n\r\n        if (rs.config.show_secs_left) document.getElementById(\"time\").innerHTML = \"Time left: \" + Math.ceil(period_length - time);\r\n    }\r\n\r\n    /*\r\n     * function for implementing % change on x and y axes. determines if dot should continue moving or not\r\n     */\r\n    function refresh() {\r\n        if (waiting) return;\r\n\r\n        var index = get_index_by_id(id);\r\n\r\n        if ((x_rate === 0 && y_rate === 0) || game_type == \"simultaneous\" || game_type == \"stage\") {\r\n            return;\r\n        }\r\n\r\n        var iterx;\r\n        var itery;\r\n        var diffx;\r\n        var diffy;\r\n        var signx;\r\n        var signy;\r\n        var scalex;\r\n        var scaley;\r\n\r\n        if (network.players[index].loc != network.players[index].target[0]) { //while we are not at our target x position\r\n            //get difference along x\r\n            diffx = Number(network.players[index].target[0]) - Number(network.players[index].loc);\r\n\r\n            if (diffx < 0) signx = 1;\r\n            else signx = 0;\r\n\r\n            scalex = x_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffx) < (scalex * 2)) {\r\n                new_loc = Number(network.players[index].target[0]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                iterx = network.players[index].iterx - 1;\r\n                if (iterx < 0) iterx = Number(0);\r\n\r\n                //check which direction we have to move in\r\n                if (signx) new_loc = Number(network.players[index].loc) - scalex;\r\n                else new_loc = Number(network.players[index].loc) + scalex;\r\n            }\r\n\r\n            if (new_loc > 1) new_loc = 1;\r\n            else if (new_loc < 0) new_loc = 0;\r\n\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n        }\r\n\r\n        if (network.players[index].pos != network.players[index].target[1]) { //while we are not at our target y position\r\n            //get difference along y\r\n            diffy = Number(network.players[index].target[1]) - Number(network.players[index].price);\r\n\r\n            if (diffy < 0) signy = 1;\r\n            else signy = 0;\r\n\r\n            scaley = y_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffy) < (scaley * 2)) {\r\n                new_pos = Number(network.players[index].target[1]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                itery = network.players[index].itery - 1;\r\n                if (itery < 0) itery = Number(0);\r\n\r\n                if (signy) new_pos = Number(network.players[index].price) - scaley;\r\n                else new_pos = Number(network.players[index].price) + scaley;\r\n            }\r\n\r\n            if (new_loc > 1) new_pos = 1;\r\n            else if (new_loc < 0) new_pos = 0;\r\n\r\n            if (new_pos > 1) new_pos = 1;\r\n            if (new_pos < 0) new_pos = 0;\r\n\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    rs.on_load(function() {\r\n\r\n        rs.send(\"config\", {});\r\n\r\n        id = rs.user_id;\r\n        group_num = rs._group;\r\n\r\n        for (var i = 0, l = rs.subjects.length; i < l; i++) {\r\n            in_group.push(parseInt(rs.subjects[i].user_id));\r\n        }\r\n        num_of_bidders = rs.subjects.length;\r\n        num_of_players = in_group.length;\r\n\r\n        current_period = rs.period;\r\n        time = 0;\r\n        network.players = [];\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n        // start player movement refresh function\r\n        //setInterval(tick, 1000);\r\n        \r\n        $scope.clock = SynchronizedStopWatch.instance()\r\n            .frequency(1).onTick(tick)\r\n            .duration(period_length).onComplete(function() {\r\n                rs.send(\"new_period\");\r\n            });\r\n\r\n        $scope.clock.start();\r\n        \r\n\r\n        setInterval(refresh, 30);\r\n        setInterval(log_data, 10);\r\n        setInterval(update_plot2, 120);\r\n        setInterval(update_plot, 60);\r\n\r\n        //initialize our player objects\r\n        for (var i = 0; i < num_of_players; ++i) {\r\n            var player = {};\r\n            player.loc = 0;\r\n            player.price = 0;\r\n            player.payoff = 0;\r\n            player.bound_lo = 0;\r\n            player.bound_hi = 0;\r\n            player.id = in_group[i];\r\n            player.valid = 1;\r\n            player.iterx = 0;\r\n            player.itery = 0;\r\n            player.target = [0, 0];\r\n            player.group = group_num;\r\n            player.color = colors[i];\r\n            network.players.push(player);\r\n        }\r\n\r\n        //prevent user input while period syncs up\r\n        $('#myModal').modal({\r\n            backdrop: 'static',\r\n            keyboard: false\r\n        });\r\n        //$(\"#myModal\").modal('show');\r\n\r\n\r\n        //plot 1 on click event handler\r\n        $(\"#placeholder\").bind(\"plotclick\", function(event, pos, item) {\r\n            if (game_type == \"stage\") {\r\n                if (allow_x) new_loc = pos.x.toFixed(3);\r\n                else if (allow_y) new_pos = pos.y.toFixed(3);\r\n            } else {\r\n                new_loc = pos.x.toFixed(3);\r\n                new_pos = pos.y.toFixed(3);\r\n            }\r\n\r\n            if (new_loc > 1) new_loc = 1;\r\n            else if (new_loc < 0) new_loc = 0;\r\n\r\n            if (new_pos > 1) new_pos = 1;\r\n            if (new_pos < 0) new_pos = 0;\r\n\r\n            //iters no longer used..\r\n            var iterx = 0;\r\n            var itery = 0;\r\n            target_pos = [Number(new_loc), Number(new_pos)];\r\n\r\n            if (game_type == \"simultaneous\" || game_type == \"stage\") {\r\n                //my_pos = [[new_loc, new_pos]];\r\n            } else if (game_type == \"continuous\") {\r\n                if (x_rate === 0) {\r\n                    rs.send(\"update_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    rs.trigger(\"update_my_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                }\r\n                if (y_rate === 0) {\r\n                    rs.send(\"update_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n                    rs.trigger(\"update_my_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                }\r\n\r\n                rs.send(\"update_target\", {\r\n                    new_loc: new_loc,\r\n                    new_pos: new_pos,\r\n                    id: id\r\n                });\r\n                rs.trigger(\"update_my_target\", {\r\n                    new_loc: new_loc,\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                });\r\n\r\n                sort_players();\r\n                find_intersect_pts();\r\n                var index = get_index_by_id(id);\r\n\r\n                //rs.send(\"update_bounds\", { index:index, new_lo_bound:new_lo_bound, new_hi_bound:new_hi_bound } );\r\n\r\n                var pay = payoff(index);\r\n                rs.send(\"update_payoff\", {\r\n                    pay: pay,\r\n                    index: index\r\n                });\r\n                rs.trigger(\"update_my_payoff\", {\r\n                    pay: pay,\r\n                    index: index\r\n                });\r\n            }\r\n\r\n            update_plot();\r\n        });\r\n\r\n\r\n        //plot 1 on hover event handler for drawing crosshairs\r\n        $(\"#placeholder\").bind(\"plothover\", function(event, pos, item) {\r\n            var a, b;\r\n\r\n            if (game_type == \"stage\") {\r\n                if (allow_x && !allow_y) {\r\n                    a = pos.x.toFixed(3);\r\n                } else if (!allow_x && allow_y) {\r\n                    b = pos.y.toFixed(3);\r\n                }\r\n            } else {\r\n                a = pos.x.toFixed(3);\r\n                b = pos.y.toFixed(3);\r\n            }\r\n\r\n            mouse = [a, b];\r\n\r\n            intersects[num_of_players + 1] = a;\r\n\r\n            options.xaxis.ticks = intersects;\r\n            options.yaxis.ticks = [0, b, 1.5];\r\n        });\r\n\r\n    });\r\n\r\n    rs.recv(\"rdebug\", function(uid, msg) {\r\n        r_debug = msg.mode;\r\n    });\r\n\r\n    rs.recv(\"data_log\", function(uid, msg) {\r\n        //intentionally blank    \r\n    });\r\n\r\n    rs.recv(\"set_payoffs\", function(uid, msg) {\r\n        intersects = find_intersect_pts();\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var pay = payoff(i);\r\n            var index = i;\r\n            rs.send(\"update_payoff\", {\r\n                pay: pay,\r\n                index: index\r\n            });\r\n        }\r\n    });\r\n\r\n    rs.recv(\"new_subperiod\", function(uid, msg) {\r\n        if (msg.curr_subperiods !== null) {\r\n            curr_subperiods = msg.curr_subperiods + 1;\r\n            cummulative_payoff = 0;\r\n\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n\r\n            document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n        } else return;\r\n    });\r\n\r\n    rs.recv(\"new_period\", function(uid, msg) {\r\n        waiting = 1;\r\n\r\n        //count up sub payoffs for total period payoff for discrete types\r\n        if (game_type != \"continuous\") {\r\n            cummulative_payoff = 0;\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n        }\r\n\r\n        if (paid_round) r.set_points(cummulative_payoff, msg.current_period, id);\r\n        document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n        $(\"#myModal\").modal('show');\r\n    });\r\n\r\n    rs.recv(\"update_player\", function(uid, msg) {\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(0);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_payoff\", function(uid, msg) {\r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.on(\"update_my_payoff\", function(msg) {\r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_bounds\", function(uid, msg) {\r\n\r\n        if (msg.new_lo_bound !== null) {\r\n            network.players[msg.index].bound_lo = msg.new_lo_bound;\r\n        }\r\n\r\n        if (msg.new_hi_bound !== null) {\r\n            network.players[msg.index].bound_hi = msg.new_hi_bound;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_iterx\", function(uid, msg) {\r\n        if (msg.iterx !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.target_x - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_itery\", function(uid, msg) {\r\n        if (msg.itery !== null) {\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.target_y - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_loc\", function(uid, msg) {\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_loc\", function(msg) {\r\n        console.log(\"updating my location\");\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_pos\", function(uid, msg) {\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_pos\", function(msg) {\r\n        console.log(\"updating my price\");\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n\r\n    rs.recv(\"update_target\", function(uid, msg) {\r\n        console.log(\"recieving update target\");\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n    rs.on(\"update_my_target\", function(msg) {\r\n        console.log(\"updating my own target\");\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n\r\n    rs.recv(\"update_subsetting\", function(uid, msg) {\r\n        //console.log(msg);\r\n        if (msg.allow_x !== null) allow_x = msg.allow_x;\r\n        if (msg.allow_y !== null) allow_y = msg.allow_y;\r\n        if (msg.curr_sub_y !== null) curr_sub_y = msg.curr_sub_y;\r\n\r\n        if (curr_sub_y == price_subrounds) {\r\n            curr_sub_y = 0;\r\n            flag = 0;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"config\", function(uid, msg) {\r\n        //assign new synchronizer\r\n        if (!chosen) keeper = in_group[Math.floor(Math.random() * in_group.length)];\r\n        chosen = true;\r\n\r\n        //set all config values\r\n        subperiods = rs.config.subperiods;\r\n        period_length = rs.config.period_length;\r\n        console.log(\"period length=\" + period_length)\r\n        t = rs.config.t;\r\n        x_rate = rs.config.percent_cpsx;\r\n        y_rate = rs.config.percent_cpsy;\r\n\r\n        if (rs.config.payoff_func === 0) {\r\n            transport_cost = linear_cost;\r\n        } else {\r\n            transport_cost = quadratic_cost;\r\n            quadratic = true;\r\n            linear = false;\r\n        }\r\n\r\n        paid_round = rs.config.paid;\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n        debug1 = rs.config.payoff_debug;\r\n        debug2 = rs.config.payoff_debug2;\r\n        debug3 = rs.config.payoff_debug3;\r\n\r\n        flow_opts = rs.config.p2_options;\r\n\r\n        scalar_x = rs.config.scale_x;\r\n        scalar_y = rs.config.scale_y;\r\n\r\n        price_subrounds = rs.config.num_sp_settingy;\r\n\r\n        payoff_mirror = rs.config.payoff_mirror;\r\n\r\n        rs.send(\"setup\", {\r\n            chosen: chosen,\r\n            keeper: keeper\r\n        });\r\n    });\r\n\r\n    rs.recv(\"setup\", function(uid, msg) {\r\n        if (msg.chosen !== null) chosen = msg.chosen;\r\n        if (msg.keeper !== null) keeper = msg.keeper;\r\n\r\n        if (id == keeper) {\r\n            var tmp = network.players;\r\n            rs.send(\"sync_net\", {\r\n                tmp: tmp\r\n            });\r\n            rs.send(\"sync_time\", {\r\n                time: time\r\n            });\r\n        }\r\n\r\n        col = '#0066FF'; //we always want to be blue\r\n\r\n        document.getElementById(\"color\").style.color = col;\r\n        document.getElementById(\"period\").innerHTML = \"Period: \" + rs.period;\r\n\r\n        var tmp_id = \"\";\r\n        for (var i = 0; i < id.length - 15; ++i) {\r\n            tmp_id += id[i];\r\n        }\r\n        document.getElementById(\"subj\").innerHTML = \"Subject: \" + tmp_id;\r\n\r\n        //remove progress bar for continuous game types\r\n        //if(game_type == \"continuous\") document.getElementById(\"prog\").style.visibility=\"hidden\";\r\n        //if(rs.config.show_secs_left === 0) document.getElementById(\"time\").style.visibility=\"hidden\";\r\n\r\n        if (paid_round) document.getElementById(\"paid\").innerHTML = \"Scoring Period\";\r\n        else document.getElementById(\"paid\").innerHTML = \"Unpaid Practice Period\";\r\n\r\n        options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: false\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: true,\r\n                clickable: true\r\n            },\r\n            yaxis: {\r\n                min: 0,\r\n                max: 1,\r\n                position: \"left\",\r\n                ticks: 1,\r\n                tickDecimals: 2,\r\n                tickColor: '#858585'\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 1,\r\n                ticks: 1,\r\n                tickDecimals: 3,\r\n                tickColor: '#858585',\r\n                tickFormatter: function(val, axis) {\r\n                    return val.toFixed(axis.tickDecimals);\r\n                }\r\n            }\r\n        };\r\n\r\n        p2_options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: true\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: false,\r\n                clickable: false\r\n            },\r\n            yaxis: {\r\n                min: 0,\r\n                ticks: 2,\r\n                tickColor: '#858585',\r\n                position: \"right\"\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 30,\r\n                tickColor: '#858585',\r\n                ticks: 0\r\n            }\r\n        };\r\n\r\n        $(\"#myModal\").modal('hide');\r\n        waiting = 0;\r\n    });\r\n\r\n    rs.recv(\"sync_net\", function(uid, msg) {\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            network.players[i] = msg.tmp[i];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"sync_time\", function(uid, msg) {\r\n        if (msg.time !== null) {\r\n            time = msg.time;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"get_silo\", function(uid, msg) {\r\n        id = r.username;\r\n        if (msg.curr_silo !== null && id == msg.id && msg.id !== null) {\r\n            silo_num = msg.curr_silo;\r\n        }\r\n    });\r\n\r\n}]);"}, "model": "expecon.page", "pk": 44}, {"fields": {"experiment": 8, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t\t<title>Finish</title>\r\n\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<table class=\"table table-bordered table-condensed\">\r\n\t\t\t\t<thead>\r\n\t\t\t\t\t<tr><th>Period</th><th>Points</th><th>Earnings</th></tr>\r\n\t\t\t\t</thead>\r\n\t\t\t\t<tbody id=\"results\">\r\n\t\t\t\t\t<tr ng-repeat=\"points in pointsByPeriod track by $index\">\r\n\t\t\t\t\t\t<td>{{ $index + 1 }}</td><td>{{ points | number:2 }}</td><td>${{ points | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"warning\">\r\n\t\t\t\t\t\t<td>Average:</td><td>{{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td><td>${{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"success\">\r\n\t\t\t\t\t\t<td>Total:</td><td>{{ $root.totalPoints | number:2 }}</td><td>${{ $root.totalPoints | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Finish", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", 'SynchronizedStopWatch', function($rootScope, $scope, rs, SynchronizedStopWatch) {\r\n\r\n \r\n  var id = 0; //player id\r\n  var current_period = 0;\r\n  var curr_subperiods = 1;\r\n  var num_of_players = 0; //number of players in our group\r\n  var price = 0;\r\n  var network = {}; //player object\r\n  var options; //plot 1 options\r\n  var p2_options; //plot 2 options\r\n  var player_pos = []; //location of opponent's positions\r\n  var target_pos = [0,0]; //our current target location for continuous time\r\n  var plot; \r\n  var x_rate = 1; //percent change per second along x axis\r\n  var y_rate = 1; //percent change per second along y axis\r\n  var keeper; //game synchronizer from our group\r\n  var chosen = false; //flag\r\n  var new_loc = 0; \r\n  var new_pos = 0;\r\n  var transport_cost;\r\n  var time = 0;\r\n  var tend;\r\n  var subperiods = 0;\r\n  var paid_round = false;\r\n  var period_length = 0;\r\n  var t; //config field\r\n  var r; //redwood\r\n  var intersects = []; //array of intersect locations on x axis\r\n  var colors = ['#FF6699','#339966','#0066CC','#CCA300'];\r\n  var mouse = []; //for drawing crosshairs on plot\r\n  var cummulative_payoff = 0;\r\n  var flow_payoff = []; //should be a better way of storing flow payoffs for scalability reasons..\r\n  var flow_payoff2 = [];\r\n  var game_type = \"continuous\";\r\n  var debug = false;   //player 'Vs'\r\n  var debug2 = false;  //intersect lines\r\n  var debug3 = false;  //market share box shading\r\n  var col; //player's blue color. may be unnecessary to store this info now\r\n  var p2_t = 0; //fake time interval for plotting flow payoffs. should be changed\r\n  var flow_opts; //flow payoff debug options\r\n  var last_20 = [];\r\n  //var l = 0;\r\n  var my_pos; //player's current location and price \r\n  var sub_pay = [[],[]]; //stores each player's payoffs at end of round for discrete games\r\n  var scalar_x = Number(1);\r\n  var scalar_y = Number(1);\r\n  var allow_x = 1; //discrete choosing settings\r\n  var allow_y = 0;\r\n  var price_subrounds = 1; //how many price rounds after a location round we have\r\n  var curr_sub_y = 0;\r\n  var curr_i = 0;\r\n  var p2_ticks = [];\r\n  var flag = 0; //for restarting position after new subgames\r\n  var waiting = 1; //to disable user interface\r\n  var in_group = []; //who is in my redwood group\r\n  var group_num = 0;\r\n  var silo_num = 0;\r\n  var r_debug = 0;\r\n\r\n  var total_flow = [];\r\n  var total_flow2 = [];\r\n\r\n  var filler = [0,0]; //for making bar graphs\r\n\r\n\r\n\r\n\r\n  rs.on_load(function() {\r\n    rs.send(\"config\", {});\r\n\r\n\r\n    id = rs.user_id;\r\n    group_num = rs._group;\r\n    \r\n\r\n    num_of_players = rs.subjects.length;\r\n\r\n    //find all players in our group\r\n    for(var i = 0; i < num_of_players; i++)\r\n      in_group.push(parseInt(rs.subjects[i]['user_id']));\r\n    num_of_players = in_group.length;\r\n\r\n    console.log(\"Number of Players: \");\r\n    console.log(num_of_players);\r\n    \r\n    current_period = rs.period;\r\n    time = 0;\r\n    network.players = [];\r\n    if(rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n    \r\n    // start player movement refresh function\r\n    setInterval(tick, 1000);\r\n    setInterval(refresh, 30);\r\n  \r\n    setInterval(update_plot2, 120);\r\n    setInterval(update_plot, 60);\r\n  \r\n    //initialize our player objects\r\n    for(var i = 0; i < num_of_players; ++i) {\r\n      var player = {};    \r\n      player.loc = 0;\r\n      player.price = 0;\r\n      player.payoff = 0;\r\n      player.bound_lo = 0;\r\n      player.bound_hi = 0;\r\n      player.id = in_group[i];\r\n      player.valid = 1;\r\n      player.iterx = 0;\r\n      player.itery = 0;\r\n      player.target = [0,0];\r\n      player.group = group_num;\r\n      player.color = colors[i];\r\n      network.players.push(player);\r\n    }\r\n    console.log(\"net players: \");\r\n    console.log(network.players);\r\n    //plot 1 on click event handler\r\n    $(\"#placeholder\").bind(\"plotclick\", function (event, pos, item) {\r\n      if(game_type == \"stage\"){\r\n        if(allow_x) new_loc = pos.x.toFixed(3);\r\n        else if(allow_y) new_pos = pos.y.toFixed(3);\r\n      } else {\r\n        new_loc = pos.x.toFixed(3);\r\n        new_pos = pos.y.toFixed(3);\r\n      }\r\n      \r\n      if(new_loc > 1) new_loc = 1;\r\n      else if(new_loc < 0) new_loc = 0;\r\n      \r\n      if(new_pos > 1) new_pos = 1;\r\n      if(new_pos < 0) new_pos = 0;\r\n      \r\n      //iters no longer used..\r\n      var iterx = 0;\r\n      var itery = 0;\r\n      target_pos = [Number(new_loc), Number(new_pos)];\r\n      \r\n      if(game_type == \"simultaneous\" || game_type == \"stage\"){\r\n        //my_pos = [[new_loc, new_pos]];\r\n      } else if(game_type == \"continuous\"){\r\n        if(x_rate === 0) rs.send(\"update_loc\", { new_loc:new_loc , id:id, iterx:iterx });\r\n        if(y_rate === 0) rs.send(\"update_pos\", { new_pos:new_pos , id:id, itery:itery });\r\n\r\n        rs.send(\"update_target\", { new_loc:new_loc , new_pos:new_pos , id:id });\r\n         \r\n        sort_players();        \r\n        find_intersect_pts();\r\n        var index = get_index_by_id(id);\r\n        var pay = payoff(index);\r\n        rs.send(\"update_payoff\", { pay:pay, index:index });\r\n      }\r\n\r\n      update_plot();\r\n    });\r\n\r\n\r\n    //plot 1 on hover event handler for drawing crosshairs\r\n    $(\"#placeholder\").bind(\"plothover\", function (event, pos, item){\r\n      var a, b;\r\n      \r\n      if(game_type == \"stage\"){\r\n        if(allow_x && !allow_y){\r\n          a = pos.x.toFixed(3);\r\n        } \r\n        else if(!allow_x && allow_y){\r\n          b = pos.y.toFixed(3);\r\n        }\r\n      } else {\r\n        a = pos.x.toFixed(3);\r\n        b = pos.y.toFixed(3);\r\n      }\r\n      \r\n      mouse = [a,b];\r\n      \r\n      intersects[num_of_players + 1] = a;\r\n      \r\n      options.xaxis.ticks = intersects;\r\n      options.yaxis.ticks = [0,b,1.5];\r\n    });\r\n    \r\n  });\r\n  \r\n  rs.recv(\"rdebug\", function(uid, msg){\r\n    \r\n    r_debug = msg.mode;\r\n  });\r\n  \r\n  rs.recv(\"data_log\", function(uid, msg){\r\n\r\n    //intentionally blank    \r\n  });\r\n  \r\n  rs.recv(\"set_payoffs\", function(uid, msg){\r\n    \r\n    intersects = find_intersect_pts();\r\n  \r\n    for(i = 0; i < network.players.length; ++i){\r\n      var pay = payoff(i);\r\n      var index = i;\r\n      rs.send(\"update_payoff\", { pay:pay, index:index });\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"new_subperiod\", function(uid, msg){\r\n    \r\n    if(msg.curr_subperiods !== null){\r\n      console.log(\"NEW SUBPERIOD\");\r\n\r\n      curr_subperiods = msg.curr_subperiods + 1;\r\n      cummulative_payoff = 0;\r\n      \r\n      for(var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n        cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n        \r\n      document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n    } else return;\r\n  });\r\n  \r\n  rs.recv(\"new_period\", function(uid, msg){\r\n    \r\n    waiting = 1;\r\n   \r\n    //count up sub payoffs for total period payoff for discrete types\r\n    if(game_type != \"continuous\"){\r\n      cummulative_payoff = 0;\r\n      for(var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n        cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n    }\r\n    \r\n    if(paid_round) rs.set_points(cummulative_payoff, msg.current_period, id);\r\n    document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n    \r\n    $(\"#myModal\").modal('show');\r\n  });\r\n  \r\n  rs.recv(\"update_player\", function(uid, msg){\r\n    \r\n    if(msg.id !== null) {\r\n      network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n      network.players[get_index_by_id(msg.id)].iterx = Number(0);\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"update_payoff\", function (uid, msg) {\r\n    \r\n    if(msg.pay !== null) {\r\n      network.players[msg.index].payoff = Number(msg.pay);\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"update_bounds\", function (uid, msg) {\r\n    \r\n    if(msg.new_lo_bound !== null){\r\n      network.players[msg.index].bound_lo = msg.new_lo_bound;\r\n    }\r\n    \r\n    if(msg.new_hi_bound !== null){\r\n      network.players[msg.index].bound_hi = msg.new_hi_bound;\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"update_iterx\", function (uid, msg) {\r\n    \r\n    if(msg.iterx !== null) {\r\n      network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.target_x - network.players[get_index_by_id(msg.id)].loc)/(0.025*(x_rate/0.5))).toFixed(3);   \r\n    } \r\n  });\r\n  \r\n  rs.recv(\"update_itery\", function (uid, msg) {\r\n    \r\n    if(msg.itery !== null) {\r\n      network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.target_y - network.players[get_index_by_id(msg.id)].price)/(0.025*(y_rate/0.5))).toFixed(3);    \r\n    }      \r\n  });\r\n  \r\n  rs.recv(\"update_loc\", function (uid, msg) {\r\n    \r\n    //console.log(\"MSG id: \" + msg.id);\r\n    \r\n    if(msg.new_loc !== null) {\r\n      network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n      network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc)/(0.025*(x_rate/0.5))).toFixed(3);\r\n  \r\n      player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"update_pos\", function (uid, msg) {\r\n    console.log(\"Recieving UPDATE_POS\\nMSG: \" + msg);\r\n    //console.log(\"MSG id: \" + msg.id);\r\n    if(msg.new_pos !== null) {\r\n      network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n      network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price)/(0.025*(y_rate/0.5))).toFixed(3);\r\n  \r\n      player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"update_target\", function (uid, msg) {\r\n    \r\n    if(msg.id !== null){\r\n      network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc)/(0.025*(x_rate/0.5))).toFixed(3);\r\n      network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price)/(0.025*(y_rate/0.5))).toFixed(3);\r\n    }\r\n    if(msg.new_loc !== null) {\r\n      network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n    }\r\n    if(msg.new_pos !== null) {\r\n      network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n    }    \r\n  \r\n  });\r\n  \r\n  rs.recv(\"update_subsetting\", function (uid, msg) {\r\n    if(msg.allow_x !== null) allow_x = msg.allow_x;  \r\n    if(msg.allow_y !== null) allow_y = msg.allow_y;  \r\n    if(msg.curr_sub_y !== null) curr_sub_y = msg.curr_sub_y;\r\n    \r\n    if(curr_sub_y == price_subrounds){\r\n      curr_sub_y = 0;\r\n      flag = 0;\r\n    }\r\n  });\r\n  \r\n  rs.on(\"config\", function(msg){\r\n    //console.log(\"CONFIGGING\");\r\n    //assign new synchronizer\r\n    if(!chosen) keeper = in_group[Math.floor(Math.random()*in_group.length)];\r\n    chosen = true;\r\n    \r\n    //set all config values\r\n    subperiods = rs.config.subperiods;\r\n    period_length = rs.config.period_length;\r\n    \r\n    t = rs.config.t;\r\n    x_rate = rs.config.percent_cpsx;\r\n    y_rate = rs.config.percent_cpsy;\r\n    \r\n    if(rs.config.payoff_func === 0) transport_cost = linear_cost;\r\n    else transport_cost = quadratic_cost;\r\n    \r\n    paid_round = rs.config.paid;\r\n    if(rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n    \r\n    debug1 = rs.config.payoff_debug;\r\n    debug2 = rs.config.payoff_debug2;\r\n    debug3 = rs.config.payoff_debug3;\r\n    \r\n    flow_opts = rs.config.p2_options;\r\n    \r\n    scalar_x = rs.config.scale_x;\r\n    scalar_y = rs.config.scale_y;\r\n    \r\n    price_subrounds = rs.config.num_sp_settingy;\r\n    \r\n    rs.send(\"setup\", { chosen:chosen, keeper:keeper });\r\n  });\r\n  \r\n  rs.on(\"setup\", function(msg) {\r\n\r\n    //console.log(\"ID: \" + id);\r\n    if(msg.chosen !== null) chosen = msg.chosen;\r\n    if(msg.keeper !== null) keeper = msg.keeper;\r\n    \r\n    if(id == keeper){\r\n      var tmp = network.players;\r\n      rs.send(\"sync_net\", { tmp:tmp });\r\n      rs.send(\"sync_time\", { time:time });\r\n    }\r\n  \r\n    col = '#0066FF'; //we always want to be blue\r\n    \r\n    document.getElementById(\"color\").style.color = col;\r\n    document.getElementById(\"period\").innerHTML = \"PerIod: \" + rs.period;\r\n    \r\n    var tmp_id = \"\";\r\n    for(var i = 0; i < id.length - 15; ++i){\r\n      tmp_id += id[i];\r\n    }\r\n    document.getElementById(\"subj\").innerHTML = \"Subject: \" + id;\r\n    \r\n    //remove progress bar for continuous game types\r\n    if(game_type == \"continuous\") document.getElementById(\"progress\").style.visibility=\"hidden\";\r\n    if(rs.config.show_secs_left === 0) document.getElementById(\"time\").style.visibility=\"hidden\";\r\n    \r\n    if(paid_round) document.getElementById(\"paid\").innerHTML = \"Scoring Period\";\r\n    else document.getElementById(\"paid\").innerHTML = \"Unpaid Practice Period\";\r\n    \r\n    options = { \r\n                  series: { shadowSize: 0, lines: { fill: false, show: false }},\r\n                  grid:  {  hoverable: true, clickable: true },\r\n                  yaxis: { min: 0, max:1, position: \"left\", ticks:1, tickColor:'#858585'},\r\n                  xaxis: { min:0, max:1, ticks:1, tickDecimals:3, tickColor:'#858585',\r\n                  tickFormatter: function(val,axis){\r\n                    return val.toFixed(axis.tickDecimals);\r\n                  }\r\n              }\r\n    };  \r\n    \r\n    p2_options = { \r\n                  series: { shadowSize: 0, lines: { fill: false, show: true }},\r\n                  grid:  {  hoverable: false, clickable: false },\r\n                  yaxis: { min: 0, ticks:2, tickColor:'#858585', position: \"right\"  },\r\n                  xaxis: { min:0, max:30, tickColor:'#858585', ticks:0 }\r\n    }; \r\n    \r\n    $(\"#myModal\").modal('hide');\r\n    waiting = 0;\r\n  });\r\n  \r\n  rs.recv(\"sync_net\", function (uid, msg) {\r\n    for(var i = 0; i < network.players.length; ++i){\r\n      network.players[i] = msg.tmp[i];\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"sync_time\", function (uid, msg) {\r\n    if(msg.time !== null){\r\n      time = msg.time;\r\n    }\r\n  });\r\n  \r\n  rs.recv(\"get_silo\", function(uid, msg){\r\n    id = rs.user_id;\r\n    if(msg.curr_silo !== null && id == msg.id && msg.id !== null){\r\n      silo_num = msg.curr_silo;\r\n    }\r\n  });\r\n  \r\n\r\n  var tick = function(tick){\r\n    \r\n    //console.log(\"NETWORK.PLAYERS = \" + network.players[get_index_by_id(id)] + \"\\n\");\r\n    waiting = false;\r\n    if(waiting) return;\r\n\r\n    if(time <= 1){\r\n      document.getElementById(\"period\").innerHTML = \"Period: \" + rs.period;\r\n      network.players[get_index_by_id(id)].color = col;\r\n    } \r\n\r\n    // generate random player clicks if debug option is set\r\n    if(r_debug){\r\n      new_loc = Math.random().toFixed(3);\r\n      new_pos = Math.random().toFixed(3);\r\n      var iterx = 0;\r\n      var itery = 0;\r\n      var msgX = {\r\n        new_loc: new_loc,\r\n        id: id,\r\n        iterx: iterx\r\n      };\r\n      var msgY = {\r\n        new_loc: new_loc,\r\n        id: id,\r\n        itery: itery\r\n      };\r\n      rs.send(\"update_loc\", msgX);\r\n      rs.send(\"update_pos\", msgY);\r\n      \r\n      target_pos = [Number(new_loc), Number(new_pos)];\r\n      rs.send(\"update_target\", { new_loc:new_loc , new_pos:new_pos , id:id });\r\n    }\r\n\r\n    time = time + 1;\r\n\r\n    // hope to fix any weird color overriding at start... \r\n    if(time == 5){\r\n      for(var n in network.players){\r\n        if(network.players[n].color == '#0066FF' && network.players[n].id != id)\r\n          network.players[n].color = colors[1];\r\n      }\r\n    }\r\n\r\n    //update progress bar\r\n    if(game_type == \"stage\") {\r\n      var width = ((250/(period_length/subperiods))*time)%250;\r\n      \r\n      $('#bar').width(width);\r\n    }\r\n    else {\r\n      var width = (250/period_length) * time;\r\n      $('#bar').width(width);\r\n    }\r\n\r\n\r\n    if (id == keeper)  rs.send(\"sync_time\", { time:time } );\r\n\r\n    //check for end of period in continous time\r\n    if(time >= period_length){\r\n      rs.send(\"new_period\", { current_period:current_period });\r\n    }\r\n\r\n    if(game_type == \"simultaneous\"){\r\n      sub_pay[0][curr_subperiods - 1] = network.players[0].payoff.toFixed(2);\r\n      sub_pay[1][curr_subperiods - 1] = network.players[1].payoff.toFixed(2);\r\n      \r\n      cummulative_payoff = 0;\r\n      for(i = 0; i < sub_pay[get_index_by_id(id)].length; ++i){\r\n        cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n      }\r\n      \r\n      if(time % (period_length/subperiods) === 0)  {\r\n        var msgX = {\r\n          new_loc: new_loc,\r\n          id: id,\r\n          iterx: 0\r\n        };\r\n        var msgY = {\r\n          new_pos: new_pos,\r\n          id: id,\r\n          itery: 0\r\n        };\r\n        rs.send(\"update_loc\", msgX);\r\n        rs.send(\"update_pos\", msgY);\r\n        rs.send(\"new_subperiod\", { curr_subperiods:curr_subperiods });\r\n      \r\n        \r\n        if(curr_subperiods == subperiods) rs.next_period(5);\r\n        \r\n        \r\n      }\r\n    } else if(game_type == \"stage\"){\r\n\r\n      if(allow_x && !allow_y) document.getElementById(\"select\").innerHTML = \"Choose x\";\r\n      else if(!allow_x && allow_y) document.getElementById(\"select\").innerHTML = \"Choose y\";\r\n      \r\n      if(allow_x && !flag){ //reset price at beginning of new subgame and keep old location\r\n        var msg = {\r\n          new_pos: new_pos,\r\n          id: id,\r\n          itery: 0\r\n        }\r\n        rs.send(\"update_pos\", msg);\r\n        flag = 1;\r\n      }\r\n      \r\n      if(time % (period_length/subperiods) === 0) { //at the end of every subperiod update new position on plot\r\n        curr_i += 4;\r\n        var iterx = 0;\r\n        var itery = 0;\r\n        var offset = 1/num_of_players;\r\n\r\n        if(allow_x){\r\n          rs.send(\"update_loc\", { new_loc:new_loc , id:id, iterx:iterx });\r\n          allow_x = 0;\r\n          allow_y = 1; //switch to price subrounds\r\n\r\n        } else if(allow_y){\r\n          rs.send(\"update_pos\", { new_pos:new_pos , id:id, itery:itery });\r\n\r\n          ++curr_sub_y;\r\n              \r\n          if(curr_sub_y == price_subrounds){ //when we reach the last price subround, start a new subgame\r\n              //if(id == keeper) rs.send(\"set_payoffs\", { curr_subperiods:curr_subperiods, id:id });\r\n               rs.send(\"set_payoffs\", { curr_subperiods:curr_subperiods, id:id });\r\n            sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n            sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n\r\n            allow_x = 1;\r\n            allow_y = 0;\r\n\r\n            rs.send(\"update_subsetting\", { allow_x:allow_x , allow_y:allow_y, curr_sub_y:curr_sub_y });\r\n            \r\n          }\r\n          \r\n          if(curr_sub_y == 2){\r\n            sub_pay[0].shift();\r\n            sub_pay[1].shift();\r\n          } \r\n        }\r\n\r\n        rs.send(\"new_subperiod\", { curr_subperiods:curr_subperiods });\r\n\r\n        if(curr_subperiods == subperiods){ //when we go through all subperiods, it's time for a new period\r\n          sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n          sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n          rs.next_period(5);\r\n        }  \r\n\r\n        rs.send(\"update_subsetting\", { allow_x:allow_x , allow_y:allow_y, curr_sub_y:curr_sub_y });\r\n        rs.send(\"set_payoffs\", { curr_subperiods:curr_subperiods, id:id });\r\n\r\n        /*\r\n        if(id == keeper){\r\n          rs.send(\"update_subsetting\", { allow_x:allow_x , allow_y:allow_y, curr_sub_y:curr_sub_y });\r\n          rs.send(\"set_payoffs\", { curr_subperiods:curr_subperiods, id:id });\r\n        }\r\n        */\r\n      }\r\n    }\r\n\r\n    var i;\r\n\r\n    intersects = find_intersect_pts();\r\n\r\n    document.getElementById(\"total_score\").innerHTML = \"Total Score: \" + rs.points.toFixed(3);\r\n    document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n    //save payoff at end of round\r\n    if(sub_pay[0][curr_subperiods - 1] === undefined){\r\n      sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n    }\r\n\r\n    if(sub_pay[1][curr_subperiods - 1] === undefined){\r\n      sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n    }\r\n\r\n    if(rs.config.show_secs_left) document.getElementById(\"time\").innerHTML = \"Time left: \" + Math.ceil(period_length - time);\r\n  };\r\n\r\n  \r\n\r\n\r\n  /*\r\n  * returns color associated with a player\r\n  */\r\n  function player_color(key){\r\n    for(var i = 0; i < network.players.length; ++i)\r\n      if(network.players[i].id == key) return network.players[i].color;\r\n    \r\n    return '#000000';\r\n  }\r\n\r\n  /*\r\n  * returns all player's positions as x,y points\r\n  */\r\n  function get_opp_pos(){\r\n    var res = [];\r\n    for(var i = 0; i < player_pos.length; ++i){\r\n      res.push([[player_pos[i][0], player_pos[i][1]]]);\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  /*\r\n  * returns points to draw a line on given axis to indicate where players can choose\r\n  */\r\n  function gen_targ_line( axis){\r\n    var res = [];\r\n    if(axis == \"x\"){\r\n      res.push([Number(new_loc) + 0.015, 0]);\r\n      res.push([Number(new_loc) - 0.015, 0]);\r\n      res.push([Number(new_loc) , 0.015]);\r\n      res.push([Number(new_loc) + 0.015, 0]);\r\n      res.push([Number(new_loc) , 0.015]);    \r\n      res.push([Number(new_loc) , 1]);\r\n    }else if (axis == \"y\"){\r\n      res.push([0, Number(new_pos) + 0.015]);\r\n      res.push([0, Number(new_pos) - 0.015]);\r\n      res.push([0.015, Number(new_pos)]);\r\n      res.push([0, Number(new_pos) + 0.015]);\r\n      res.push([0.015, Number(new_pos)]);\r\n      res.push([1, Number(new_pos)]);\r\n    }\r\n    \r\n    return res;\r\n  }\r\n\r\n  /*\r\n  * returns market boundary points for a given player to draw 'payoff area' box\r\n  */\r\n  function get_market_bounds(key){\r\n    var res = [];\r\n    for(var i in network.players){\r\n      if(network.players[i].id == key){\r\n        res.push(network.players[i].bound_lo);\r\n        res.push(network.players[i].bound_hi);\r\n        res.push(network.players[i].price);\r\n      } \r\n    }\r\n    \r\n    var out = [];\r\n    out.push([res[0], null]);\r\n    \r\n    out.push([res[0], 0]);\r\n    out.push([res[0], res[2]]);\r\n    \r\n    out.push([res[1], res[2]]);\r\n    out.push([res[1], 0]);\r\n    out.push([res[1], null]);\r\n    \r\n    return out;\r\n  }\r\n\r\n  var tmp_a0 = [];\r\n  var tmp_a1 = [];\r\n  var market_b = [];\r\n\r\n  /*\r\n  * redraws and updates data for plot 1\r\n  */\r\n  function update_plot(){\r\n    if(waiting) return;\r\n    \r\n    sort_players();\r\n    var tmp = [target_pos];\r\n    var i = get_index_by_id(id);\r\n    \r\n    get_players();\r\n      \r\n    var tmp_col = '#C7C7C7';\r\n    \r\n    if(game_type == \"continuous\"){\r\n      targ_line = [];\r\n      my_pos = [[player_pos[i][0], player_pos[i][1]]];\r\n    } else if(game_type != \"continuous\"){\r\n      var axis = \"\";\r\n      if(allow_x && !allow_y) axis = \"x\";\r\n      else if(!allow_x && allow_y) axis = \"y\";\r\n      \r\n      tmp_col = '#B20000';\r\n      targ_line = gen_targ_line(axis); //draw axis choosing line if in discrete time\r\n    }\r\n    \r\n    tmp_a0 = [];\r\n    tmp_a1 = [];\r\n    market_b = [];\r\n    intersects = [0,mouse[0],1];\r\n    \r\n    var opp_pos = get_opp_pos();\r\n    \r\n    if(debug1){ // display payoff debug options, player \"V's\"\r\n      tmp_a0 = a(0);\r\n      tmp_a1 = a(1);\r\n    } \r\n    \r\n    if(debug2){ //market intersection lines\r\n      intersects = find_intersect_pts();\r\n      intersects[num_of_players + 1] = mouse[0];\r\n      options.xaxis.ticks = intersects;\r\n    } \r\n    \r\n    if(debug3) { //payoff area shading\r\n      market_b = get_market_bounds(id);\r\n    }\r\n    \r\n    options.xaxis.ticks = intersects;\r\n    \r\n    plot = $.plot(\"#placeholder\", [\r\n      \r\n      { data: opp_pos[0], color: player_pos[0][2], points:{ show: true, radius: 3, fill: true, fillColor:player_pos[0][2] }},\r\n      { data: opp_pos[1], color: player_pos[1][2], points:{ show: true, radius: 3, fill: true, fillColor:player_pos[1][2] }},\r\n      { data: targ_line, color: '#000000', lines:{ show: true, fill: false }},\r\n      { data: tmp, color: tmp_col, points:{ show: true, radius: 3, fill: true, fillColor:tmp_col }},\r\n      { data: tmp_a0, color: player_color(network.players[0].id), lines:{ show: true, fill: false }},\r\n      { data: tmp_a1, color: player_color(network.players[1].id), lines:{ show: true, fill: false }},\r\n      { data: my_pos, color: '#000000', points:{ show: true, radius: 5, fill: true, fillColor:'#0099FF' }},\r\n      { data: market_b, color:col, lines:{ show: true, fill: 0.25 }}\r\n    \r\n    ], options);\r\n    \r\n  }\r\n\r\n  var date = 0;\r\n  var old_date = 0;\r\n\r\n  /*\r\n  * rewdraw and update flow payoff plot\r\n  */\r\n  function update_plot2(){\r\n    if(waiting) return;\r\n\r\n    if(game_type == \"continuous\"){\r\n      //make sure everyone is sorted\r\n      sort_players();\r\n      find_intersect_pts();\r\n      \r\n      //so we can get the correct payoffs\r\n      var index = get_index_by_id(id);\r\n      var pay = payoff(index);\r\n      rs.send(\"update_payoff\", { pay:pay, index:index });\r\n\r\n      //let's find how long it was since we updated our payoffs      \r\n      date = new Date();\r\n      date.getTime();\r\n    \r\n      var d = date - old_date;\r\n      old_date = date;\r\n    \r\n      p2_t += 0.12;\r\n      //p2_t += d;\r\n      \r\n      cummulative_payoff += network.players[get_index_by_id(id)].payoff * (d/(period_length * 1000));\r\n\r\n      document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n    \r\n      if(flow_opts == \"all\"){\r\n        //push all player's data to be plotted\r\n        flow_payoff.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n        flow_payoff2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n        \r\n        total_flow.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n        total_flow2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n        \r\n        //add extra white space to front of plot to hide end time\r\n        p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n    \r\n        last_20.push(network.players[get_index_by_id(in_group[0])].payoff);\r\n        last_20.push(network.players[get_index_by_id(in_group[1])].payoff);\r\n        \r\n        //get rid of data more than 20seconds old\r\n        if(time >= 20){ \r\n          flow_payoff.shift();\r\n          flow_payoff2.shift();\r\n          last_20.shift();\r\n          p2_options.xaxis.min = flow_payoff[0][0];\r\n        }\r\n    \r\n        //scale flow payoff y axis to fit m ax payoff during the last 20 seconds \r\n        p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n    \r\n        plot2 = $.plot(\"#placeholder2\", [\r\n          { data: flow_payoff, color: player_color(network.players[get_index_by_id(in_group[0])].id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }},\r\n          { data: flow_payoff2, color: player_color(network.players[get_index_by_id(in_group[1])].id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }}\r\n        ], p2_options);  \r\n          \r\n      } else if(flow_opts == \"own\"){\r\n        //in this case we only plot our own payoff data\r\n        flow_payoff.push([p2_t, network.players[get_index_by_id(id)].payoff]);\r\n        total_flow.push([p2_t, network.players[0].payoff]);\r\n    \r\n        last_20.push(network.players[get_index_by_id(id)].payoff);\r\n        p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;    \r\n        \r\n        if(time >= 20){\r\n          flow_payoff.shift();\r\n          last_20.shift();\r\n          p2_options.xaxis.min = flow_payoff[0][0];\r\n        } \r\n    \r\n        p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n    \r\n        plot2 = $.plot(\"#placeholder2\", [\r\n          { data: flow_payoff, color: player_color(id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }}\r\n        ], p2_options);\r\n        \r\n      } else if(flow_opts == \"none\"){\r\n        //otherwise we plot nothing\r\n        return;\r\n      }\r\n    \r\n    } else { \r\n      //else we are in discrete time\r\n      p2_options.xaxis.tickDecimals = 0;\r\n      p2_options.xaxis.min = 0;\r\n      p2_options.xaxis.max = curr_subperiods + 2;\r\n      p2_options.xaxis.ticks = p2_ticks;\r\n      \r\n      if(flow_opts == \"all\"){\r\n        flow_payoff  = plot_data(sub_pay[0], 0, 1);\r\n        flow_payoff2 = plot_data(sub_pay[1], 0, 1);\r\n        \r\n        //set player's payoff bar graphs to have 25% opacity\r\n        if(network.players[0].id == id) filler = [0.25, 0];\r\n        else if(network.players[1].id == id) filler = [0, 0.25];\r\n          \r\n        plot2 = $.plot(\"#placeholder2\", [\r\n          { data: flow_payoff , color: player_color(network.players[0].id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }, lines:{ fill:filler[0] }},\r\n          { data: flow_payoff2, color: player_color(network.players[1].id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }, lines:{ fill:filler[1] }}\r\n        ], p2_options);\r\n      \r\n      } else if(flow_opts == \"own\"){\r\n        \r\n        flow_payoff = plot_data(sub_pay[get_index_by_id(id)], 0, 1);\r\n        \r\n        plot2 = $.plot(\"#placeholder2\", [\r\n          { data: flow_payoff, color: player_color(id), points:{ show: false, radius: 4, fill: true, fillColor:'#C7C7C7' }, lines:{ fill:0.25 } }\r\n        ], p2_options);\r\n        return;\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n   \r\n  /*\r\n  * nicely package flow payoff data for discrete time types\r\n  * div is now always 1 since lines should overlap\r\n  */\r\n  function plot_data(input, offset, div){\r\n    var res = [];\r\n    var i = 0;\r\n    p2_ticks = [];\r\n    for(var a in input){\r\n      if(input[a] !== 0){\r\n        res.push([i + ((1/div)*offset), null]);\r\n        res.push([i + ((1/div)*offset), input[a]]);\r\n        res.push([i + ((1/div)*(offset + 1)), input[a]]);\r\n        res.push([i + ((1/div)*(offset + 1)), null]);\r\n        p2_ticks.push(i);\r\n        i++;\r\n      }  \r\n    }\r\n    return res;\r\n  }      \r\n\r\n  /*\r\n  * payoff debug \"V\" generating function\r\n  */\r\n  function a(index){\r\n    var res = [];\r\n    var player = network.players[index];\r\n    if(player === null || player === undefined) return;\r\n    \r\n    var l = player.loc * -1;\r\n    var p = player.price;\r\n\r\n    for(var x = 0; x <= 1; x = x + 0.01){\r\n      res.push([x, p + Math.abs(l + x)]);  \r\n    }\r\n    \r\n    return res;\r\n  }\r\n\r\n  /*\r\n  * default\r\n  */\r\n  function linear_cost(){\r\n    var res = [];\r\n    var pos = get_index_by_id(id);\r\n    \r\n    for(var i = 0; i < network.players.length; ++i){\r\n      if(i != pos) res.push(Math.abs(network.players[pos].loc - network.players[i].loc) * t);  \r\n    }\r\n    \r\n    return res;  \r\n  }\r\n\r\n  /*\r\n  * d^2 * t\r\n  */\r\n  function quadratic_cost(){\r\n    var res = [];\r\n    var pos = get_index_by_id(id);\r\n    \r\n    for(var i = 0; i < network.players.length; ++i){\r\n      if(i != pos) res.push(Math.abs(Math.pow(network.players[pos].loc - network.players[i].loc),2) * t);  \r\n    }\r\n    \r\n    return res;   \r\n  }\r\n\r\n  /*\r\n  * find only players that have a market share\r\n  */\r\n  function validate_players(){\r\n    var tmp = network.players;\r\n    var res = [];\r\n    //var index;\r\n    var i;\r\n\r\n    for(i = 0; i < network.players.length; ++i){\r\n      var p1 = network.players[i];\r\n      tmp[i].valid = 1;\r\n    \r\n      for(var j = 0; j < network.players.length; ++j){\r\n        var p2 = network.players[j];\r\n        \r\n        //for every player excluding yourself compare price\r\n        if(i != j){\r\n          if(p1.price > p2.price + t * Math.abs(p1.loc - p2.loc)){\r\n            tmp[i].valid = 0;\r\n            \r\n            //update player's new market bounds\r\n            var new_lo_bound = 0;\r\n            var new_hi_bound = 0;\r\n\r\n            network.players[i].bound_lo = new_lo_bound;\r\n            network.players[i].bound_hi = new_hi_bound;\r\n          } \r\n        }\r\n      }\r\n    }\r\n    \r\n    for(i = 0; i < network.players.length; ++i){\r\n      if(tmp[i].valid == 1) res.push(network.players[i]);\r\n    }\r\n    \r\n    return res;\r\n  }\r\n  function refresh(){\r\n    //if(waiting) return;\r\n    \r\n    var index = get_index_by_id(id);\r\n    \r\n    if((x_rate === 0 && y_rate === 0) || game_type == \"simultaneous\" || game_type == \"stage\") {\r\n      return;\r\n    }\r\n    \r\n    var iterx;\r\n    var itery;\r\n    var diffx;\r\n    var diffy;\r\n    var signx;\r\n    var signy;\r\n    var scalex;\r\n    var scaley;\r\n\r\n    if(network.players[index].loc != network.players[index].target[0]){ //while we are not at our target x position\r\n      //get difference along x\r\n      diffx = Number(network.players[index].target[0]) - Number(network.players[index].loc);\r\n\r\n      if(diffx < 0) signx = 1;\r\n      else signx = 0;\r\n      \r\n      scalex = x_rate*0.0833333;\r\n\r\n      //if we are close enough, snap into place to avoid overshoot\r\n      if(Math.abs(diffx) < (scalex*2)){\r\n        new_loc = Number(network.players[index].target[0]);\r\n      } else {\r\n        //otherwise keep moving player along\r\n        iterx = network.players[index].iterx - 1;\r\n        if(iterx < 0) iterx = Number(0);\r\n\r\n        //check which direction we have to move in\r\n        if(signx) new_loc = Number(network.players[index].loc) - scalex;\r\n        else new_loc = Number(network.players[index].loc) + scalex;\r\n      }\r\n      \r\n      if(new_loc > 1) new_loc = 1;\r\n      else if(new_loc < 0) new_loc = 0;\r\n  \r\n      rs.send(\"update_loc\", { new_loc:new_loc , id:id, iterx:iterx });\r\n    }\r\n\r\n    if(network.players[index].pos != network.players[index].target[1]){ //while we are not at our target y position\r\n      //get difference along y\r\n      diffy = Number(network.players[index].target[1]) - Number(network.players[index].price);\r\n\r\n      if(diffy < 0) signy = 1;\r\n      else signy = 0;\r\n  \r\n      scaley = y_rate*0.0833333;\r\n      \r\n      //if we are close enough, snap into place to avoid overshoot\r\n      if(Math.abs(diffy) < (scaley*2)){\r\n        new_pos = Number(network.players[index].target[1]);\r\n      } else {\r\n        //otherwise keep moving player along\r\n        itery = network.players[index].itery - 1;\r\n        if(itery < 0) itery = Number(0);\r\n        \r\n        if(signy) new_pos = Number(network.players[index].price) - scaley;\r\n        else new_pos = Number(network.players[index].price) + scaley;\r\n      }\r\n      \r\n      if(new_loc > 1) new_pos = 1;\r\n      else if(new_loc < 0) new_pos = 0;\r\n    \r\n      if(new_pos > 1) new_pos = 1;\r\n      if(new_pos < 0) new_pos = 0;\r\n    \r\n      rs.send(\"update_pos\", { new_pos:new_pos , id:id, itery:itery });\r\n    }\r\n\r\n  }\r\n\r\n  /*\r\n  * returns array of all points along x-axis that correspond to an intersection\r\n  */\r\n  function find_intersect_pts(){\r\n    var res = [];\r\n    res.push(0);\r\n\r\n    var tmp = validate_players();\r\n    var i;\r\n    \r\n    for(i = 0; i < tmp.length - 1; ++i){\r\n      res.push (( t * (tmp[i + 1].loc + tmp[i].loc) + (tmp[i + 1].price - tmp[i].price)) /(2*t) );\r\n    }\r\n    \r\n    res.push(1);\r\n    \r\n    var new_lo_bound;\r\n    var new_hi_bound;\r\n    var index;\r\n    \r\n    if(id == keeper){\r\n      for(i = 0; i < tmp.length; ++i){\r\n        new_lo_bound = res[i];\r\n        new_hi_bound = res[i + 1];\r\n        index = get_index_by_id(tmp[i].id);\r\n        \r\n        network.players[index].bound_lo = new_lo_bound;\r\n        network.players[index].bound_hi = new_hi_bound;\r\n      }\r\n    }\r\n    \r\n    return res;\r\n  } \r\n\r\n  /*\r\n  * payoff = market_share * price\r\n  */\r\n  function payoff(index){\r\n    var market_share = Math.abs(network.players[index].bound_hi - network.players[index].bound_lo) * scalar_x;\r\n    \r\n    return market_share * (network.players[index].price * scalar_y);\r\n  } \r\n\r\n  /*\r\n  * sorts players in descending order. bubblesort\r\n  */\r\n  function sort_players(){\r\n    var grp = network.players;\r\n    var len = network.players.length;\r\n    \r\n    for(var i = 0; i < len - 1; ++i){\r\n      for(var j = 0; j < ((len - 1) - i); ++j){\r\n        if(grp[j].loc > grp[j + 1].loc){\r\n          var tmp = grp[j + 1];\r\n          grp[j + 1] = grp[j];\r\n          grp[j] = tmp;\r\n        }\r\n      }\r\n    }\r\n    \r\n    network.players = grp;\r\n  }\r\n\r\n  /*\r\n  * returns index in network object array of player with id 'key'\r\n  */\r\n  function get_index_by_id(key){\r\n    //console.log(\"KEY: \" + key);\r\n    var res = -1;\r\n    for(var i = 0; i < network.players.length; ++i){\r\n      //console.log(\"NET ID: \" + network.players[i].id)\r\n      if(network.players[i].id == key) return i;\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function get_players(){\r\n    if(waiting) return;\r\n    if(id == keeper) {\r\n    var value = network.players;\r\n      rs.send(\"data_log\", { value:value , curr_subperiods:curr_subperiods, silo_num:silo_num });\r\n    }\r\n    \r\n    for(i = 0; i < network.players.length; ++i){\r\n      player_pos[i] = [network.players[i].loc, network.players[i].price, network.players[i].color];\r\n    }\r\n  }\r\n\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 45}]